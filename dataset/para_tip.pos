96	you can also do a print_r($_session); to have a dump of this variable and see the content....
97	here is an example for using pdo to connect to a db, to tell it to throw exceptions instead of php errors (will help with your debugging), and using parameterised statements instead of substituting dynamic values into the query yourself (highly recommended):
152	make it a goal mitigate the pain of making changes in the future: a global is dangerous because it's hard to manage in a single spot. what if i want to make that database connection context aware in the future? what if i want it to close and reopen itself every 5th time it was used. what if i decide that in the interest of scaling my app i want to use a pool of 10 connections? or a configurable number of connections?
194	it's a pretty common misconception that you have to manually serialize objects before putting them in session. that is not the case. you can simply assign an object instance to a slot in $_session, and php will automagically serialize and unserialize it for you, between requests.
257	as a little side note, if this is being printed in a html document, i presume you are passing the output though something like htmlentities... just in-case the input $path contains something like a [script] tag (xss).
502	you shouldn't use htmlentities when saving it. you should use htmlentities when displaying it. the rule of thumb is not to encode/sanitize the data until you need to. if you do htmlentities on it when you save then you have to do html_entity_decode on the text when the user wants to edit the input. so you sanitize for what you need and nothing more. when saving it, you need to sanitize for sql injection, so you mysql_real_escape_string it. when displaying, you need to sanitize for xss, so you htmlentities it.
503	also, i am not sure if you saw darryl hein's comment, but you really do not want magic_quotes enabled. they are a bad, bad, thing and have been deprecated as of php 5.3 and will be gone altogether in php 6.
504	in addition to paolo's answer about when to use htmlentities(), unless you're using an old version of php, the correct way to sanitize for insertion into a mysql db is to use prepared statements which are part of the mysqli extension. this replaces any need to use mysql_real_escape_string().
546	'null' is the unique thing that uninitialized variables refer to. you can set a variable to refer to null. there is also the 'unset' state meaning the variable doesn't exist at all. you can check that via the isset() function. most often used to check if an element of array exists and is, for example, a way to see if $_get['op'] has received a querystring param. you can also make a variable unset (remove an element of an array) via the unset() function. there is also a function empty() which will check if a variable is either null, false, 0, or an empty string
547	i'm not 100% familiar with mysqli but i've played with a lot of pgsql commands doing this sort of thing and i think what your looking for is mysqli-result->fetch_assoc. this will produce an associative array that you can loop over pretty easily like so:
599	call htmlspecialchars() on any untrusted strings you are sending to the browser as html. this will help prevent xss attacks.call mysql_real_escape_string() on any strings you are putting directly into sql statements. this will protect you from sql injection attacks.
736	for one thing, sql injections and html injections can (should) be protected in another way. sql injections are prevented by parametrized queries (a must-have this day and age); and html injections are prevented by htmlspecialchars() method, which should be called right before outputting the string to the user. don't store encoded strings in the db or (even worse) - encode them as soon as receiving them. working with them will be a hell later.
923	i know you weren't explicitly asking about security, but escape your user fields! you should never ever directly use $_get or $_post variables in your queries. you must escape them first. your current code is wide open to exploitation. you can escape each field using mysql_real_escape_string()
925	so as long as you don't eval() user input, you're safe with sessions. the only thing that links a user to its specific piece of session data is the cookie with the session id, which can manually be changed. if you have a lot of active sessions, they might guess a valid session id and hijack someone else's session.
1287	one thing that you need to seriously reconsider is using unsanitized data from $_post and $_session. this is potentially a major security risk to your site as someone can fairly easily perform some sql injection.
1288	i would also look at migrating your code to use mysqli or pdo, as mysql is quite outdated.
1574	an important thing you should never do is to insert values directly into the database. in your code dont use $_post directly. why? there are many reasons, like sql injection attack, data inconsistency etc. use a function like mysql_real_escape_string or other functions available (another topic for discussion)
1576	so, first of all, correct (see the quotes in array indexes) and escape (as @footy already told you) your query  [insert "better using prepared statements" phrase here]:
1719	you must single-quote dates in mysql.  additionally, since you are acquiring it directly from $_post, you are advised to escape it with mysql_real_escape_string() first.
1807	first of all if those fields are inputs then isset() will always return true. what you probably want to check is if they are not empty. so you should use empty() function for that.
1813	the reason why your code isn't working is not because of your boolean logic, but because of your use of isset(). in the case of a &lt;input type="text"&gt;, the $_post['fieldname'] will always be set, regardless of if the value is empty or not.
1814	use $_post['fieldname'] != '' instead to determine if the user has entered a value. do not use empty(), as this will return any falsy value as empty (0, 000, false, etc...).
1893	do you use header("location: xxxxx") redirects anywhere on your page (or included pages)? if you use them without calling exit() immediately after, the script will continue to execute.
1971	also, as outis noted, keep in mind that you have the option of using prepared statements instead of just raw sql queries.
2015	i don't see what's wrong with your code. as suggested, try var_dumping the content of both $_server and $_session at the beginning of session_check() to see what they contain.
2039	and if you want to do a more adjustable filtering, i’d use a html parser like domdocument, traverse the dom tree and remove the nodes i don’t want.
2050	you can use array_keys() to extract the keys from an array.
2068	like the call to session_start, the call to session_regenerate_id should be done at the beginning of the script, before anything is sent to the browser.so, here, in the block at the "top" of your index.php.
2108	if you know both of the values are guaranteed to be strings, then == and === are identical since the only difference between the two is that === checks to see if the types are the same, not just the effective values.
2279	after you call htmlentities(), call nl2br(). the web browser ignores plain newline characters so you need to convert them to &lt;br /&gt; elements to make them show up.
2658	back to injection protection... to protect against injection without moving to prepared statements via mysqli or pdo, use mysql_real_escape_string() in place of htmlentities();
2723	just beware : you have to think about escaping data before injecting it back into the form (see htmlspecialchars and/or htmlentities) ; that is true for everything you get from the user (and, probably, for php_self too, i'd say) ;-)
2734	bindparam takes a variable, to reference, and doesn't pull in a value at the time of calling bindparam. i found this in a comment on the php docs:
2744	hear_about is an array and filter_var() does not handle arrays correctly. instead use filter_var_array():
2747	the implode function (doc) "transform" an array to a string by concatenating the array values with the given glue. so you can just concatenate selected "how did you hear about us?" options with a comma and then use the resulting string as the other data.
3080	you are using array_push which adds elements to the end of the array. you should be using array_unshift, which will prepend new items to the beginning of the array.
3086	if you need to check on each page whether there's still an active facebook session or not, look at fb.getloginstatus() in the javascript sdk, or make an api call to (for example) /me/permissions to check your access token is still valid
3089	this works because array_unshift puts elements at the beginning of the array, therefore the new sub-array will always be element 0.
3091	it depends on what do you want to use for. if you want to display it, use htmlspecialchars. if you want to use as a database query, you might use mysql_real_escape_string in case of mysql. (or prepared statements)
3155	as escaping depends on the system you are sending the data too, my suggestion would be to use the functions provided by php, specifically created for each system.
3156	or use prepared statements (mysqli, pdo)don't add backslashes yourself : why do that when proper and well-working (and well-tested !) escaping functions already exist ?for html output, use htmlspecialchars or htmlentities.
3232	whenever data is coming from user, sanitize it(take special attention if its storing in database.). so pdo with prepared statement is a must. what else you do is added bonus.yes (opinions will differ here from person to person) for preventing sql injection (assuming you are using prepared statement). though i prefer storing the raw data in database even if it means sacrificing for some malicious xss code may contain it. while outputting, take utmost care.no. use htmlpurifier (with a view that you are outputting from a database.)
3234	validate input and store it using prepared statements. prepared statements will protect your database against sql injections. typically, you don't want to strip out html tags on input because doing so could lead to a loss of data integrity.when displaying user-generated data (output), you can guard against xss by using a combination of htmlentities and mb_convert_encoding.
3564	array_values is correct solution. the little thing is that it does not affect given array, but returns an array. so you have to assign it to another variable. for example:
3629	you can use urlencode, this will convert any spaces to +.
3679	of course, you're wide open to attacks like this as everyone else is saying. you need to look into mysqli or pdo to sanitize your input...
3705	also your code is subject to sql injection - use mysql_real_escape_string before the query:
4211	also, sending the secret $number through form is not nice, you might want to read about php sessions
4432	secondly, if you want to get rid of any danger of sql injection, it would be much easier to use prepared statement, so something like the following is all that is needed.
4500	if your search string was more complicated, you could use a regular expression instead.
4685	variables are not parsed by interpreter inside single quotes. you should use double quotes or explicit string concatenation.
4687	besides if you're using method="post" in your form, you can only get the inputs value through the $_post array.
4702	as an aside, you should always develop with errors cranked all the way up, and you should be monitoring for any kind of error (warning, notice, etc).  this will help prevent potential logical bugs, and it tends to keep code clean.  (there seems to be a correlation between code that never issues notices and well written code.)
4779	if you need to check whether the query returned rows, use mysql_num_rows.
4780	you should also consider switching to mysqli, as mysql has been deprecated.
5010	call htmlentities (or, usually better, htmlspecialchars) only at the point where you're taking some plain text and concatenating or echoing it into an html page. that applies whether the text you are using comes from a submitted parameter, or from the database, or somewhere else completely. call mysql_real_escape_string only at the point you insert plain text into an sql string literal.
5109	you should also consider switching to mysqli or pdo extensions since mysql_query() is deprecated and will be removed in future updates of php versions.
5180	it is safe to return user data based on a $_session variable if you are certain of its validity because you set it yourself in code.  it is not safe to return data based on a session variable that you get from $_post.
5284	try that. strpos tells you the position of the search string if it's there, and false if it isn't.
5880	you need to cleanse any and all input from the user.  if $get or $post exist on the same line as a query string, you need to escape it like this one:
5883	in general, in development mode, you might wanna check your php.ini for error reporting, and check error_log on your web server to see if errors are reported there.  if the query fails, it may not show up on the page output, but it may show up in the error log.
6055	similarly when outputting your variables like $row['site_name'] always make sure you escape them for html, for example using htmlspecialchars($row['site_name']).
6130	escaping manually will result in double escaped values. and in my personal opinion the greatest advantage of placeholders ? in sql statements is that you don't have to take care about escaping.
6230	1) the php mysql_ functions have been deprecated. that means the functions will be removed in future versions of php. you should use pdo or mysqli instead
6355	also, for consistency, change mysqli_connection_error() to if ($mysqli-&gt;connect_error) or something. mysqli_* offers both procedural and oo style, but please, don't mix the two.according to the docs, you can't use this, as yourcommonsense pointed out to me, because it was broken until php 5.2.9 and 5.3.0. it's recommended to keep the procedural check to ensure compatibility.
6421	i haven't use htmlentities before, but it seems like a bit more robust version of urlencode (which i use a lot).  you might want to try:
6534	first of all switch from mysql_ to mysqli_ or pdo they are more reliable.then, check the spelling (host, user and password) and the case ! password and username are case sensitive.
6627	if there is certain words or characters you want to strip out, the easiest way to do it would be to store an array of those words or characters and use str_replace on the string before you explode.
6637	note: many answers will invariably suggest you not use mysql, but pdo or mysqli.
6871	if you really dont want to reload the whole page, the only way to do it is to use an ajax request to a page where your php code is. simply use jquery and replace your php code with this :
6882	another thing, don't use addslashes() to secure queries, but use your library's dedicated function, such as mysql_real_escape_string() for mysql. or better use query bindings with prepared statements and parametrized queries.
7105	regarding your second question: recall that $_get will contain the result of a form using the get method, while $_post will contain data from post method forms. $_get purpose is to contain url parameters, if they exist (to be precise, a get method form will pass all its parameters via the url).
7395	consider adding session_regenerate_id() after the session_start. this will prevent session cookie stealing (phpsessid in your cookies' id is regenerated on each pageload if you use the above function), which is probably what is happening (apart from the exit problem on the answer above)
7434	second, about your database calls.  i answered a similar question here but the basic gist is that you create a single database instance and inject that into the classes needing database access.  as far as mysqli, if that is what you like using go for it.  its awesome that you aren't using the older, deprecated mysql_*.
7557	and try to avoid using mysql_* functions due to they are deprecated.instead use mysqli_* functions or pdo statements
7670	however, you should do some cleaning on $_post["submit"] since your code is open to sql injections.
7782	use var_dump($_post['fruit']); to see your array structure and how you can access it.
7908	yes, it does! not only are mysql_ functions deprecated and no longer being maintained, partly due to the security risk they allow by the use of sqlinjection, they also lack also object oriented capabilities.
7909	the best secure way of connecting and handling database queries that exists now is, either via the mysqli or pdo interfaces. you should learn either one that suits.
7933	$ _post or $ _get are two special functions of php that are used to get variables from a user-filled form. while using these functions, a user may encounter an error - notice: undefined index. this error can be avoided with the help of php isset (). this error will be notified, but that depends on the configuration of the server. notice: undefined index is a minor error and hence not notified by default. with the help of the error_reporting function, the type of error reported can be changed.
7936	"enough sanitization" thoroughly depends on what environment you're talking about. sanitization for mysql should be considered entirely separate from sanitization for web output, and you should handle them separately to avoid a lot of hassle.
7937	htmlspecialchars($val) at output time will prevent any malicious tags from being rendered, because &lt; and &gt; characters are converted into their entity representations and not rendered as tag delimiters.use the ent_quotes modifier if you are outputting something that is inside an html element's quoted attribute, such as &lt;input name="email" value="&lt;?php echo htmlspecialchars($email,ent_quotes); ?&gt;" /&gt;
7938	that should be all you need, unless you have special requirements.  strip_tags() shouldn't really be used for sanitization, as it can be fooled with badly formed html.  sanitization is a worthy goal, and if you can keep your contexts separate, you'll run into fewer problems with data manipulation between them.
7958	if you are using htmlspecialchars, it is going to turn anything that is not alphanumeric into an html entity, so it will actually render the symbol in the browser rather than using it as markup. you could probably store whatever the user enters as plain text, then just echo it back on to the page when it needs to be displayed. this code worked when i tried it for i believe what you are trying to do.
7978	print_r should be used only to print out an array in a human readable format (for debugging). perhaps you want to do something like:
8103	array_search returns false if $needle is not found. false casts to 0 when used as an integer. you might want to consider array_filter for your use case:
8136	even if you do all the above, as i have mentioned, your database, still be weak to mysql injections, therefore, you are better of learning pdo or mysqli
8650	i won't suggest compiling from code on production server unless there is an absolute necessity.
8683	as suggested, some code and more details would be helpful. but if you have multiple form fields on the same page, and depending on the action, you want to submit different sets of those fields, then just wrap them in different &lt;form&gt;&lt;/form&gt; elements. a post submit only submits the form fields contained with that particular  block.
8731	this is a minor gotcha, if 'jpg' happens to occur at the start of the string being searched. strpos will properly return 0 for the hit, but 0 evaluates to false in a standard equality test. you'll end up with (false != false).
8732	if you're using strpos to exclusively test for the existence of a substring, you have to use the strict === and !== operators (note the extra =), which not only compare values but types as well, where 0 !== false will evaluate to true. integer 0 is not strictly equal to boolean false, even though they have the same value of 0.
8878	if you are having trouble getting non-ascii characters into the database, that's a different problem which you should solve first instead of going for unsustainable workarounds like storing html-encoded data. there are a number of posts here all about getting php and databases to talk proper utf-8, but the main thing is to make sure your html output pages themselves are correctly served as utf-8 using the content-type header/meta. then check your mysql connection is set to utf-8, eg using mysql_set_charset().
8879	yes, that's correct. as long as you do this you are not vulnerable to sql injection. you might be vulnerabile to html-injection (causing xss) if you are html-escaping at the database end instead of the template output end. because any string that hasn't gone through the database (eg. fetched directly from $_get) won't have been html-escaped.
9018	if you want to debug php, i suggest you use var_dump (or print_r), this will show you if you have an array or an object.  a javascript console will always show object, and is not very useful.
9181	try to usr mysql_fetch_array($sql,mysql_assoc)or mysql_fetch_assoc($sql) instead of mysql_fetch_array($sql)by default mysql_fetch_array return non associative array.
9182	do not select * from table_name. it's better for performance to use select column1, colum2 from table_namemysql module is deprecated. it's better to use pdo mysql module page mysql api comparison
9390	just unsetting $element will not work, because this variable is not a reference to the arrays element, but a copy. accordingly changing the value of $element will not change the array too.
9410	assuming you have access to your php.ini file, you may want to look into what these commands do. they may or may not fit your needs, but they can be helpful to avoid session hijacking / fixation by not allowing the phpsessid variable to be passed via url and also making it inaccessible via javascript.
9411	brute force attacks can be mitigated by using proper hashing. to  look into bcrypt or scrypt for more detail. you can also check out this discussion for a little more information on this.
9533	as a side note, it looks like you're using the deprecated mysql extension (and putting post values straight into a database query opening up the possibility of sql injection), i strongly recommend mysqli.
9605	stop using deprecated mysql_* functions. use mysqli or pdo instead.your code is subjected to sql injection attack, as you directly allow post values to be inserted in your query.
9647	you use session variables to store variables across pages. at the top of each page add session_start()....to decare the session variable then do this:
9648	now, on your test.php file, if you add the session_start at the top of the page you can access that variable: $_session['id'].
9719	you should also look the method prepare from pdo to properly set dynamic values in your query instead of building it by yourself.
9720	edit: according to the php documentation on strings i'm wrong and you can interpret an array between double quotes, sorry for the confusion.
9914	warning 1: your code is vulnerable to xss, you should not print raw user input back to the page, pass it through htmlspecialchars().
9915	warning 2: it's also vulnerable to mail header injection attacks. you should validate the $email that you insert into the headers, or not insert any user input at all into the headers.
10000	foreach creates a copy of each array element, so unsetting $media[$media_key] only unsets from the copy; and you want to unset from the original $data array:
10071	the problem is that you're using array_pop on an index of the potentials array.array_pop is designed to pop the last element off the end of an array.
10121	array_pop() accepts an array as argument and it remove the last value from the array (returning it). if you want to get the value of that array element, you should do something like
10184	it's because you're not using the correct regular expression. is there a reason you can't use explode()? regex is problematic, overly complicated at times, and much slower. if you know you'll always be splitting at the br tag, explode is much more efficient.
10196	it would be better if you used pdo or mysqli, so you could use parametrized queries instead of string substitution. your code is in serious danger of sql injection.
10205	you have used mysql, but it's being deprecated. so you need to consider using mysqli or pdo.
10304	you can use $_server['query_string'] to get the query string. and then use parse_str():
10320	you have to set the cookie before any output to the browser. try moving all echo lines somewhere below the setcookie call. you could do something like this:
10382	simply use mysqli's prepared statements and you will be fine. to also keep you safe from xss, always htmlspecialchars user input in html output. even better is to filter the input to only what you need, and save only the filtered input to your database.
10675	first, you should know that the mysql extension is deprecated, you should use mysqli or pdo_mysql.
10717	however, you ought to use prepared statements in order to make your queries properly formatted.
10776	well, if you don't want xss problems, then using htmlspecialchars() is a good idea.  if you didn't, someone could store a malicious &lt;iframe&gt;, or &lt;script&gt; in your code.
10899	you may use addslashes() for entering apostrophe and as you have already said use stripslashes() for echoing.use addslashes() only if you want to add apostrophes for more escaping functions used mysql_real_escape_string
11047	note that it is better to use pdo or similar for interacting with the database in any case, at least in the long run. with prepared statements and bounded parameters, you do not even have to escape the parameters yourself.
11050	when using in a database query, use prepared statementswhen outputting in an html page, use htmlspecialcharswhen using as part of an url, use (raw)urlencodewhen executing external commands, use escapeshellarg, or escapeshellcmd respectively.…
11054	you are doing it wrong! mysql_real_escape_string should be used before putting the mail string into the sql query, but you probably want to save it in its original form, without escaping, into the session array.
11057	this is not how it works in zf. you cannot pass the form name to ispost() unless you override ispost() in your code.
11163	you could use isset() to see if the checkbox has been checked.
11202	the warning you're getting is probably a 500 error -- meaning your server is not set up to display errors to you, or you don't have it enabled in your index.php file.
11203	the error you're getting, but not seeing is: "fatal error: can't use function return value in write context" because you can't use isset on a function.
11214	if you have not included the function then you will get a fatal error in the execution of the script. try to remove the clear() all together and see what happens, the changed line should be
11229	one nice feature of pdo is that the pdostatement implements the traversable. this means you can iterate it directly:
11515	you are doing an extra foreach, just check if the key exists in the array, you can do that using in_array. and to show all, just reverse the arrays order
11548	also, if your users are logging out, you should also delete/invalidate their session variables.
11554	browsers automatically collapse all line breaks, tabs, and spaces in between the characters into a single space, which produces the "not as readable" output. in order to preserve all these, try wrapping your print_r output in &lt;code&gt;&lt;pre&gt;.
11600	it does store the boolean value. so when you get the value you should expect a boolean value. if you use var_dump($a) instead of print_r you will see that it is stored perfectly as
11654	so the answer is: no, the connections will not be shared between and re-used by the mysql extension and pdo.
11678	if you're having trouble debugging, use var_dump or even in combination with gettype() around the argument you're trying to implode. you never need to implode json objects, they are decoded perfectly find. make sure you know the difference between csv (comma separated values) and json.
11838	put session_start() before anything else; this function initializes the session data that you will be accessing in $_session.
11839	not exactly sure what you're trying to achieve with the rest of it all, but session_start() first is a starting point...
11917	just loop the array containing the values, and check if they are found in the input string, using strpos
11930	if you want to get an object, you have to pass an associative array to json_encode:
11979	firstly, when your handling the user's input and placing directly into a url, please make sure you url encode it. even if e-mail addresses can't have spaces, etc.
11980	if you are using a form  to handle the user input without javascript intervention, don't worry about url encoding, that should happen automatically.
11983	use post for your credentials form.  by default, the method is get which will append the parameters in the url. obviously, this means checking variables in the $_post array instead of the $_get array.
12003	i think you mean $globals (notice the s) which is a suber global variable and therefore can be accessed from anywhere in the php script (also from within functions or methods). there is nothing wrong about that.
12029	no field with the name post_id eists in your form. you are however passing the id manually through the url in your form action. to get the id, you would use $_get['id'] rather than $_post['post_id']
12116	once the query has been sent to the database, what is done on php variables doesn't matter anymorethe only thing you'll do that will have an impact is when you'll commit or rollback.which means that unsetting the php variable will have no impact on the transactions/data on the db side.
12125	also, adopt what helion3 said and check that _post actually has keys/values before you assign it to the _session
12276	also, you may want to check $_server['http_accept_language'] instead of $_server['http_user_agent'] for the language of the user.
12301	ajax is the best way to accomplish what you are looking for also your code is extremely vulnerable to sql injection i suggest doing your homework on pdo prepared statements to help safeguard against it. take a look here reload mysql data inside a div using ajax
12309	isset checks if a value is set and returns a boolean, so $num1 and $num2 will be either true or false. so you are not adding up the actual values.
12433	pdo::exec() returns the number of rows not an object that you can fetch on.
12461	the specific answer to this really depends on what type of database you are using and whether you want to do this validation in php or in the database. i would lean towards using triggers on the database to check for overlapping times on any insert, this way, if you end up having more than one interface to insert or update these record (e.g. front end app and a web service) then you don't need to re-write the logic, and you can let the database take care of maintaining the integrity. your php could then catch the exception thrown on these particular inserts/updates (you are using pdo?) when the trigger throws an exception.
13082	&amp;&amp; isset is not function. only isset is a language construct which checks a session variable or post variable is set.for adding another variable also you need to use &amp;&amp; isset($_post['variable'])
13092	also, i suggest you to test if the variable is not empty, because fields like 'input text' will always exist even if it is empty.
13093	you can use empty function to test if it exists and not empty
13132	you should definitely consider to use another mysql extension as well, mysql_* is deprecated, use mysqli_* or pdo. i prefer pdo.
13133	it's also worth noting that the mysql_* set of function is now deprecated. it'd be better to use mysqli or pdo.
13170	i may be wrong but i think the only way to unset the element in the array would be to look up the index that matches the value referenced by the variable you have, then unsetting that element.
13171	well, anyway, something along those lines.  however, keep in mind that this is not super efficient because each time you need to unset an element you have to iterate over the full array looking for it.
13173	when you unset the reference, you just break the binding between variable name and variable content. this does not mean that variable content will be destroyed.
13256	use an auto-increment for the primary key of your table (the id i assume);switch to pdo or mysqli and prepared statements (the mysql_* functions are deprecated);add error handling. using pdo or mysqli it is extremely easy to have your database calls throw exceptions so you will know exactly when and what goes wrong.
13572	you need to use the $_session variable. it allows you to pass data between pages.
13574	make sure that you call session_start() at the top of your page, before you have outputted any html to the page. otherwise you will cause a headers error.
13577	you can then access them on any other php page with the session_start(); code on top.note however that this session data gets deleted when the user closes his/her browser. for more persistant, "long-lived" variables use $_cookie variables or store values in db and access the variables from there.
13686	if you reload the page after submitting a form, it will keep the post data. to solve this follow the below things :
13796	also note that mysql_* functions are deprecated, use mysqli_* instead.
13866	security concern:you are not escaping user submitted data when passing it to the sql statement opening you up to sql injection. if you insist on using mysql then i would suggest adding before your mysql query:
13879	mysql_real_escape_string will escape invalid characters, so they can be used quite safely in a query. but then, still, you are using an outdated, deprecated set of functions to connect and work with mysql. therefor, please read the warning on the mysql introduction page (which is also repeated on just about every other page related to this library).
13880	so far for mysql. next chapter is sending and storing passwords. you should do this preferably over https (maybe you do already, i hope so). and as a rule, you should never store passwords as plain text in a database. actually you should not store them encrypted either. you should hash them. and even then, add some salt.the exact details are to long to explain here, but there are good explanations for this. here is a random one: serious security: how to store your users' passwords safely
13884	and i recommend you to use better approach to sql handling like using pdo extension.
13924	now, opening files like this. it is a really, really bad idea. if you are only using the code for your own use then okay, but even so it may cause problems that you have not thought about. the best thing is to never use client-provided data for opening files, but if you have to then make sure the path is clean and does not contain malicious stuff (such as a preceding slash or dot, etc).
13953	keep in mind that as you have this now, your begging for an sql injection attack. please use pdo and bind the values.
13955	please do not use the mysql_* functions anymore and switch instead to the mysqli_ functions or pdo. mysql_ is with php 5.5 deprecated and won't be supported by php >= 5.5.in addition to this i should mention, that your script is vulnerable for mysql injections. always escape your values before inserting them into a database query!
13956	my code example contains the function mysql_real_escape_string which is like i told you deprecated. if you stick to mysql_* this is the least you can do to secure your application.
14038	simple, non production code is not allowed on production (var_dump, print_r, et al. are never useful in production). enforce by in order of preference either build / testing system, source control, enforcing using only wrapper functions which can easily be disabled centrally, or if you really must, production server configuration.
14047	you may also want to take a look at krumo which is an amazing replaement for var_dump and print_r by displaying php variables in a structured way.
14064	i would first say that you use pdo, and make your queries safer by using  prepared queries.pdo prepared statement
14180	also, for the target upload directory, you might want to append it with $_server['document_root'] so that the target directory is not dependent on where your script is located, but it's always based on the root.
14324	check if you have magic quotes turned on and make sure you turn them off. also, you'll want to use htmlspecialchars to escape the special characters. otherwise, they can just close your textarea and wreak other havoc.
14473	you are open to sql injection and you should use prepared statements.
14474	you also can't mix mysqli and mysql. don't use mysql_ functions, they are not as secure and deprecated.
14475	when doing selects for password and username, ensure case sensitivity by using binary and put  limit 1 at the end, to ensure only 1 record in return.
14482	you should use mysql and not mysqli since its deprecated you're accessing $row's associative array keys, so you need the function to return associative array whild mysqli_fetch_array() returns numeric keys.
14681	you can just use isset() to make sure the value is present. this will stop the error.
14763	try to add session_start(); at the top of the file right below &lt;?php where u defined the index() function, if i'm right the sessions didn't even start (idk), but try to add it..
14878	alternatively, you can put error_reporting(0); at the top of your file and it will hide all of these warnings. however, it's not reccomended because if there is a real error you won't know what it is until you remove that line.
15078	now, implode() has to make a string, so it converts each item in the array it's given to a string before proceeding. for an object, it will try to call __tostring() (or the equivalent "under the hood" for built-in objects), but closure has no such method. this is where your error is coming from.
15080	as mark baker points out in a comment, you can use array_map to execute your callback; reusing $something from above, and breaking it down for clarity:
15094	in html, the value of the input will be passed to php script will be based on the name attribute. so, in order to pass the value after the submission, the html code like below:
15413	using document_root helps a lot when including multiple files scattered around your document root - using relative paths here gives me a headache. if you really want full urls in your pages, though, you can try using $_server['server_name'] for that matter, but i really don't understand the need to do so.
15501	plus you can remove the htmlspecialchars() functions as they are only useful when looking at echoing html code to the browser - as you are uploading an image (not html code...) there is no need for any of the variables to be compared with this function in the first place. even then you would only use htmlspecialchars() when writing to the web-page to be seen by users. (i.e. when you want &lt;br /&gt; to be seen by people reading your web-page.)
15636	variables from an html form passed as part of the url get put into a $_get array by php. so if you have a textbox with a name of "age" and a user submits it with a value of "20" you will see this url:
15756	there's a lot that could go wrong in the database - from connecting, to how the data is stored, to how the data is retrieved. if you are using a database at all to store this data before it is sent back to the browser, take extra care to make sure the database is properly encoding and retrieving utf-8 text.
15757	if you were to use mb_strtolower, you could pass an encoding like: mb_strtolower($summoner, 'utf-8');this properly handles special characters.
15776	then you can sanitize both the name and the value field. you also probably want to look in to using pdo to prevent exploits better.
15815	the array_filter function loops through the array and passes the value into a callback.  if the callback returns true, it will keep the value, otherwise it will remove the value from the array. after all items are passed in the callback, the result array is returned.
16048	also, the mysql_* extension is deprecated as of php 5.5.0, and will be removed in the future. instead, the mysqli or pdo_mysql extension should be used. see also mysql: choosing an api guide and related faq for more information.
16072	short answer: check to see if register_globals is enabled on your live server using var_dump(ini_get('register_globals')) or phpinfo() . if register_globals is enabled, the preferable solution is to disable register globals—it leads to security problems and as of php 5.3 is deprecated.
16238	now of course you should upgrade your code to mysqli or mysqlpdo since the php mysql package is not supported anymore.
16343	finally, be careful when rendering data "raw" to html - if this data (which you do not control yourself) contains an angle bracket, it will break your website. thus, you'll need to wrap everything above in htmlspecialchars or htmlentities, thus:
16478	this will work, granted you use the correct credentials to connect to your database and you copy and paste this in correctly.  and yes, you can use the variable directly in double quotes (") so that is why i did not use . to append the strings.
16618	there is nothing at all wrong with saving "lots of data" in the $_session. by doing this you are not at all increasing transfer size or anything so you're not affecting the client as $_session is purely server-side.
16699	you don't seem to quite understand how long the variables stay in memory. in php, once the script has finished, every memory that was allocated by that script is freed, so $calendar_id_val is no longer in memory.if you want to use values from a form when next the user posts a form (the next request made), then you're already half-way there, try:
16701	note that the use of sessions is to be recommended, because sessions store the data server-side, whereas cookies are stored on the client's machine. this makes them vulnerable (can be tempered with) and unreliable (client can disable/reject your cookie)
16712	the / is making it post to the root of your website, not the current url. $_server['php_self'] contains the path of the current script relative to the document root.
16742	also, if you have any other code in this specific page, make sure you have exit; after the header() function to prevent it from executing before redirection.
16775	alternatively you could use fetchall to select whole dataset into a variable. then you wouldn't need to loop
17162	that's right! if you are already using pdo the proper way as documented using prepared statements, it will be enough to protect you from mysql injection.
17164	now, as you can probably tell, i haven't used anything to escape/sanitize the value of $_post["color "]. and this code is secure from myql-injection thanks to  pdo and the power of prepared statements.
17165	it is worth noting that you should pass a charset=utf8 as attribute, in your dsn as seen above, for security reasons, and always enable pdo to show errors in the form of exceptions.
17170	but, using prepared statements as shown above will always be safer, than using any of the functions that start with mysql_
17361	if this is exactly what you're trying to do, then you don't need a regular expression at all. leverage php's built-in functions for string manipulation! not only it will be faster, it will be more readable too.
17625	your present code is open to sql injection because you are not escaping any data input.use mysqli with prepared statements, or pdo with prepared statements.
17735	yes, it seems to be correct. basically you specify an array to array_unique and it gives you unique items out of the array.
17747	i use the php function isset() to check if a post was sent or not
17907	secondly, codeigniter does not utilize php's native $_session, they implement their own. so you should not test if it is set with &lt;?php if (isset($_session['fail'])): ?&gt;
18039	however i won't show you how to fix this because you're using deprecated mysql_* functions in your code.  you need to switch to mysqli or to pdo.  there are plenty of tutorials on how to use those libraries.
18190	first off you should be using the intval() function php provides to safely cast a string as an integer.
18191	secondly if you want numbers like 0.01 or 0.999 you need a float, integers do not have decimals, so you should actually be using floatval().
18224	simple answer, yes. if any part of your sql statement comes from a request or form submission by the client, you need to sanitize/escape it.
18251	nb: it is better to use mysqli or pdo instead of mysql since mysql is officially deprecated since php 5.5
18488	also you could install the php module xdebug which could modify the output of var_dump for better readability: http://xdebug.org/docs/display
18571	also remember, session_start should always be the first line of the page in which you need to use sessions.
18614	in your php don't use $_post['forminfo'] but rather $_post['nameoftheinput'].  further, you should sanitize the input, like this:
18617	better is to use pdo as mentioned above, mysql_ can be used "safely" on &lt; php 5.5.
18637	for pdo, try pdostatement-&gt;getcolumnmeta(). for mysqli, there's mysqli_result-&gt;fetch_fields(), mysqli_result-&gt;fetch_field() and mysqli_result-&gt;fetch_field_direct(). for mysql, replace it with pdo or mysqli.
18638	sounds like $homedetails[0], etc. are not set. you could use a debugger to examine these values before calling addfixtures() or examine them by adding simple echo or var_dump() statements right before the call.
18644	btw.some tips for the future:1. the id's fields should have unique values.2. you should consider protecting your query from sql attacks. here you do not even escape the string which is given by the user.3. as far as i remember the mysql is obsolete so try to use mysqli instead.
18681	1- check if you make session start  session_start(); in the begining of your review.php file
18701	i i completely agree that pdo is good choice to avoid sql injections but, you know at such situations you are unable to debug your queries. but if you use mysqli wisely and properly check sql injections when you input, then there will not be a problem.
18785	and try to avoid using mysql_* functions due to they are deprecated.instead use mysqli_* functions or pdo statements.
18817	use php sessions instead of cookies. the session variables are server-side. php will automatically handle the session management. you can also overload its functionality if you want more control.
18819	for extra safety, you should store the remote address that was used to login, and compare it on each page load. this is to make sure that nobody hijacked the session id and is pretending to be logged in from another location.
18889	also, as a side note, every line in php needs a semicolon ; at the end of it. many of yours don't. and the 3rd line is missing an opening bracket { though i'm not sure if that is just an artifact of your copy paste or not.
18890	i would recommend using jquery to listen for events as well. the events api for jquery will let you listen for events on objects. so, something like this:
18915	the name attribute in &lt;input&gt; and &lt;textarea&gt; define what name the field has. the data of the fields is then sent to the server with the corresponding name. so if you send data with name="title" but reference $_post['cdtitle'] in php, the data won't be found because it's in $_post['title'].
19170	first you have to check to use mysqli or pdo instead of mysql.
19172	when using mysqli you should use mysqli_prepare and mysqli_stmt_bind_param instead of using the php variables directly in your sql string. this will help you to avoid sql injection.
19328	your code is prone to sql injection, you are still using mysql even though it has been deprecated, you should use either mysqli or pdo with prepared statements.
19579	i'd  say you think it is false because the string's position might be 0 which evaluates to false (assuming you are using a needle that is present in the string). you should always compare with ===.
19638	htmlentities() is not a guaranteed way to build legal xml.
19641	htmlentities() will convert a number of non-ansi characters (i assume this is what you mean by utf-8 data) to entities (which are represented with just ansi characters). however, it cannot do so for any characters which do not have a corresponding entity, and so cannot guarantee that its return value consists only of ansi characters. that's why i 'm suggesting to not use it.
19659	to prevent against any sql injection you should use mysqli_real_escape_string or you can use prepared statements that accomplish the same thing.
19870	you should be able to use ifnull to convert nulls to (say) empty strings in your where clause.  for example, name like '%%%s%%' would become ifnull(name, '') like '%%%s%%'.
20152	you also need to prepare your output for output to the browser with something like htmlspecialchars($row[...]). that way you avoid potential problems if the output contains html tags (javascript, etc.).
20288	isset() will return true if the variable is set but empty (eg. ''). you can use empty() instead.
20348	you should also know that the code you have written is very dangerous and prone to sql injection. never, ever, use get/post variables directly in the query. please use mysqli with prepared statements or pdo.
20384	$_server["remote_addr"] is the best you can do to find out the client's ip address. that is not identical to the domain of the site that a possible bot would be working for, though, and will not tell you in what ways your content is re-used.
20436	yes, you can. as far as i know pdo is completely object-oriented, but you may want to look into mysqli which allows both procedural and oo styles.
20469	however, there is much bigger problem in this code. you don't escape the values, therefore open an sql injection. just think what would happen if your password contains a single quote, such as test'123:
20504	i advice you to use pdo or mysqli look this is deprecated . so better turn to pdo or sqli
20594	and you have to start_session() at the top of all your files.
20757	the problem is that when you 'enter the values via the url', they'll end up in $_get instead of $_post. try changing those lines in add.php.
20901	of course, you have to add session_start() at the top of the page!
21168	strpos returns false when the find_string is not found at all.
21349	and you have an sql injection error, you should switch to pdo (or mysqli) and prepared statements with bound variables.
21514	if you are inserting into a database, then you should usually be handling your escaping using parameterized queries (via prepared statements).
21520	addslashes is unsafe for sql and you should never use it in that context. use parameterized queries instead as quentin suggests.
21633	yes there is a risk. you don't want to blindly import user input into your symbol table. you should take the time to validate and/or sanitize user input. the filter_var function can help with this.
21634	when inserting into a database, use the driver's escape mechanism to eliminate the possibility of injection. if you're using mysql_* functions, you'd use mysql_real_escape_string. however, it is much better to use pdo and parameterized queries for this.
21734	do no repeat yourself. you are writing all the stuff twicealways check for errordo not stack too much code in one line. make your code distinct, step by step. need a program to create an sql query? okay. get the product of this code in a variable and pass it over. do not fold all the program in a single line.format your sql properly
21737	as you have been told already, mysql ext is obsoleted. you have to use use pdo instead, as it's the only choice for php users whose only idea of database interaction is direct calls to api.
21805	warningisset() only works with variables as passing anything else will result in a parse error. for checking if constants are set use the defined() function.
21959	use pdo prepared statements. its secure and easy to use. here's something you could do to store it as a session. instead replace session variables with normal variables and you could call to this each time without using session variables.either way its possible, but session method would not call database each and every time after its initialized this way.
22038	there are a couple of issues.  first, mysql_query is a deprecated php function and should be replaced with mysqli_query.  all functions in your code should use the mysqli prefix instead of mysql (so mysql_fetch_assoc should be changed to mysqli_fetch_assoc).  this function also takes a parameter providing a connection to the database, which is done with mysqli_connect.  so your code should have something like this:
22057	first of all the way you store your credentials in cookies is very dangerous. anyone who has access to your computer or to your network if you're not using ssl can steal your cookies and log in to your account.
22062	you use sha1 for hashing your passwords. but this algorithm is a bad practice. you should use bcrypt or at least use an individual salt for each password you encrypt with sha1 and store that next to the password in the database
22065	you store both the email and the hashed password in a cookie. this can be very dangerous. you shouldn't store the password even if it is hashed in an cookie. the best practice is to hash a randomly created string of characters with a high entropy and store only that in the cookie and in the database. when the user logged in once with that cookie you should refresh the cookie with a new hash.
22294	side note: since you are already using pdo, you might as well take advantage of prepared statements. this provides the benefit of not having to worry about sql injections.
22919	php treats empty or null variables as "false" so you don't have to check the $_post variables again, after you assign them to your local variables. i don't see where you create $to or $body, though, so that's a problem.
23151	in order to convert a comma-separated string into an array of individual values you can break up the string with a function like explode(), which takes a delimiter and a string as its arguments, and returns an array of the delimiter-separated values.
23229	first of all you can safely remove the following statements. the parameters are already escaped by pdo. you don't have to do it using obsolete methods. that method will also not work if you don't have an active mysql connection
23399	array_multisort is used to compare elements from different arrays (or sub-arrays) at the same time. you want to compare elements of only one array, so you use usort. the fact that those elements are themselves arrays is irrelevant.
23586	first, don't use mysql_ functions, as they've been deprecated since php 5.5, and removed in 7.0. use mysqli_ functions instead, or pdo.
23626	ss looks to be a number too, so checking if it is numeric using is_numeric will help stop sql errors, if for some reason it is not.
23688	sidenote: it seems you're saving plain naked passwords, if its available to you (php 5.5 or greater), i'd suggest you should use password_hash + password_verify to handle your login module for hashing those passwords. if you have php 5.4 or lower and can't use the built-in, there's already a compatibility pack library for that.
23786	to prevent first order sql injection you can use pdo with mysql prepared statement.and when you want to display it to the html page use
24001	strpos - find the position of the first occurrence of a substring in a string
24197	as @sudhir said, you can use in_array() function in php. this function search your expected item through an array and will return true if it can find it. so using the code that @sudhir suggested, will work for you as you want.to know more about in_array() function, see http://php.net/manual/en/function.in-array.php
24256	never trust the session id being sent, even if the cookie is tied to a specific subdomain, since the sessions for all subdomains are being stored in the same directory on the server.a solution for this might be:  ini_set(session.save_path, "/path/to/your/folder/$clientid") then you'd have a unique directory dedicated for each client for storing sessions. the benefit of this approach is that your $_session won't contain information related to another subdomain.
24293	i'd also recommend you use mysqli since mysql functions were deprecated in php 5.5.0, and it removed in php 7.0.0.
24410	you should be validating the contents of $id to be within the bounds you expect, and if you try to use it as a string when it is really an array, the functions acting on it will throw warnings or errors.  since php is weakly typed, a function expecting an integer will happily run if you pass it an array, but will likely crash and burn with errors all over your logs or the screen.
24512	warning: mysql_ finctions are deprecated as of php 5.5.0, and will be removed in the future. instead, the mysqli or pdo_mysql extension should be used.
24673	first of all, $_get does not include the values of posted form parameters. $_post or $_request will work, although the latter may not be wise to use because depending on the php configuration, it may include cookie values.
24674	second, $query is not valid sql. in particular, sql uses and rather than &amp;&amp;. also, the column names have to match the rest of your code if you use the mysql_assoc option:
24675	mysql_real_escape_string() is used to prevent sql injection. if you were using either the mysqli extension or pdo, you would have prepared statement functionality available to you, which you should use instead.
24707	when you include a script with include or require, that script has access to all variables in scope at the inclusion site. in your example, you can access $somevar directly from somescript.php (you could also directly access $_post or anything else).
24835	you are vulnerable to mysql injection, because you do not escape your variables.
24838	mysql methods are depreciated in php, try to use pdo extension.use the following
25177	please be informed that mysql functions are deprecated and not recommended. use mysqli or pdo instead. have a reference from following queries.
25372	edit: on another note, it may not be a good idea to delete items from the array while you're looping over it. i'm not sure how a foreach compiles but if you get weird errors you may want to separate your finding logic from the deleting logic.
25574	another approach is to use array_key_exists to check for the existence of an array key. you can use an if statement, or shorten it with a ternary.
25643	password_default - use the bcrypt algorithm (default as of php 5.5.0). note that this constant is designed to change over time as new and stronger algorithms are added to php. for that reason, the length of the result from using this identifier can change over time. therefore, it is recommended to store the result in a database column that can expand beyond 60 characters (255 characters would be a good choice).
25757	try to debug your code. you may use var_dump($result-&gt;fetch_assoc()) to see if the query has some results.
25936	if you submit a form that has multiple select boxes, only the name of the checked ones will be in the $_post array. so to know whether or not a checkbox was on you have to check for the occurence of its name in $_post.
25986	based upon your comment, you're checking for $_post['campo'] despite the fact that your &lt;form&gt; tag's method is a get request.  you should instead check the value of $_get['campo'] (or $_request['campo']).
25991	your method is get, which won't give you what you're after if you're looking for the values in the post collection, which $_post does.  just change the method on your form to method="post" to get this working correctly, otherwise use $_get on the php side, if a get is what you're actually after.
26103	you may also be outputting before header, so place session_start(); at the top of your script. which is what's going on here. your code puts on the brakes as soon as it hits starting the session and failed on you silently.
26157	you need to put the url inside the action attribute that does the form processing, not the function:
26161	but this is open to sql injection, another way to do safer queries is to prepare them:
26203	first of all you should not use the mysql_* functions of php anymore. these functions are marked as deprecated and will be removed in the next major php release.
26463	of course, as was already mentioned in comments, you shouldn't be using the mysql_* family of methods within php anymore as they are deprecated. consider using mysqli or pdo instead, along with prepared statements.
26929	in_array won't help you here because you have a string, not an array. what you're looking for is the strpos() function:
26932	you can use strpos() to check for the existence of a substring inside a string, like this:
27159	you have missed the session_start() at the top of your dologin.php. it is required at the top of each page before any output has started.
27160	without session_start(); you won't have access to create or update a session variable (in your case $_session['user'])
27164	you should switch to mysqli_* or pdo since mysql_* functions are deprecated.
27409	if you wish to use mysql object oriented, use mysqli or pdo driver.
27551	also as zan mentioned, don use mysql_* functions, but mysqli_* or pdo...
27562	warning : this is vulnerable to sql injections. don't use mysql_* commands, try pdo ou mysqli instead. prepared statements will help avoiding them.
27762	note that you will have to santise the value, mysql_real_escape_string is normally used to do this.
27763	finally the mysql_* methods are deprectaed and you really shouldn't use them. see here for information.
27903	you should also rather use mysqli functions and not deprecated mysql functions and the better option will be prepared statements.
27997	the problem here is that you binding parameters with bindparam, which uses binding by reference. in your case you should use bindvalue instead:
28169	you should never use values you get from a user ($_get, $_post or $_request) without sanitizing them. you should read this: validating sanitizing and escaping user data.your select statement in the function soto_posts_filter_restrict_manage_posts is useless as you do not do anything with it.  also, your &lt;select&gt; code suggests that only one value can be used so why use distinct ? also, shouldn't that statement link to the post id ?
28239	you should also look up functions for preventing email injection, and also run strip_tags on every post value to prevent xss attacks on your form.
28406	however, as with any other time in programming, if you find yourself writting the same code over and over, you probably need to write an abstraction.
28692	preg_match matches the first match and then stops. the result array always contains the entire matched expression in its 0 index and all capture groups in the following indices starting at 1. e.g.:
28697	if you want to match all occurrences of the expression, use preg_match_all.
28932	to get variables from the query string, you need to use $_get. $_post represents data that is sent to the script via the http post method.
28933	to get the value of a variable, you need to use $_get
29165	i strongly recommend to use mysqli with a prepared statement in order to avoid the risk of sql injection.
29727	sidenote : this(mysql_*) extension is deprecated as of php 5.5.0, and will be removed in the future. instead, the mysqli or pdo_mysql extension should be used. switching to preparedstatements is even more better to ward off sql injection attacks !
29813	trim removes leading and trailing white-space. it is useful if you have a free form input in which rogue spaces might be typed. you will need to do further sanity checking afterwards.
29947	if you can use array keys immediately (without conversion), use isset() because it's obviously much faster than in_array() due to way keys are looked up and because it's a language construct.
30318	opening note: mysql_ has been deprecated and replaced by mysqli. the use of mysql_ is highly discouraged. the use of pdo is much better and safer.
30337	on the next page, you can now use $_post['ordernumber']. to use sessions, make sure session_start(); is placed before retreiving or storing and make sure nothing has been printed to the screen, nor any headers have been output before issuing a session_start();
30467	additionally, you should not be using the mysql - library it is insecure, and is deprecated - use mysqli or pdo.
30521	php doesn't make copies when you do assignments. strings and numbers are immutable, so there's no need to copy them. objects are copied by reference. and arrays use copy-on-write technology, so it only copies them later if the old reference still exists and you then modify the copy.
30589	to get your selected value, you have to reach the $_get or $_post supertables after the user submits the form.
30751	i suggest you to create a header.php, where you initiate the html to the start of the body tag and add the css files to the html there. in the other php files you just have to use include_once 'header.php'; and this way your css is included earlier, than your query runs. i hope this will solve your problem. note: if you use sessions, session_start() must be the first row because sessions can't be started after any headers sent.
30806	if you want to use the foreach structure, you need to ensure that the values passed to it are an array. currently you are passing a non-array value to the foreach so it is never firing.
30857	either add all of them using hidden input fields (you can access them via $_post then) or start a session using session_start() and save them in $_session. make sure to start the session at the very top, there must not be a single byte sent before!
31053	you can't access $_session variables before calling session_start. also, your serializing of the data is probably pointless. session data is stored server-side. serializing would be used if you wanted to dump the session state to a file or to a database or something.
31113	if you use php5 (and you should, given that php4 has been deprecated), you should use pdo, since this is slowly becoming the new standard. one (very) important benefit of pdo, is that it supports bound parameters, which makes for much more secure code.
31162	that being said: don't use the mysql_* functions anymore. they are deprecated. use pdo or mysqli with prepared statements instead. you are currently wide open to sql injection attacks.
31179	however - you shouldn't introduce parameters in this way, and the mysql_* functions are deprecated. have a look at mysqli (http://uk3.php.net/manual/en/book.mysqli.php) or pdo (http://uk3.php.net/manual/en/book.pdo.php) and parameter binding.
31197	your present code is open to sql injection. use mysqli with prepared statements, or pdo with prepared statements, they're safer.
31265	when you are using functions like mysql_select_db and mysql_query it basiaclly means that you are using a deprecated mysql style.
31277	use mysqli_* instead of mysql_* as it is deprecated. you can also use pdo. more on mysqli_*
31433	in php, preg_match will return 1 if the match succeeds and 0 if it fails.  you can query m.success to get the equivalent value (i.e., true if the match succeeds and false if it fails).
31648	use array_slice() to get part of an array. you pass it the array you want part of and the position you want to start it (minus one since arrays are zero-based keys).
31737	also, when you make an sql query, you should sanitize variables you pass to it. otherwise your code is opened for sql injections.you can do, at least, like this:
31738	also, just for future, it is recommended to use pdo because mysql extension is deprecated and will be removed.
31955	make use of isset to check if a cookie exists and then try setting one.
32039	the mysqli extension does support mysqli_multi_query() but i still recommend doing one query at a time.
32044	by using a keyed array, there is no duplication and you can easily check how frequently a hashtag is used by just accessing $trending[$hashtag]. additionally, you can get the list of all hashtags in the trending array using $allhashtags = array_keys($trending);.
32062	since you're using a prepared statement with multiple queries, you need to use emulated prepared statements.  refer to pdo support for multiple queries (pdo_mysql, pdo_mysqlnd)
32067	in my personal opinion, i think this is bad practice to put multiple queries into one pdo statement.  you should consider using a transaction with pdo and multiple statements which allows you to more easily figure which query is causing issues and rollback if an error occurs.
32068	secondly, you are using prepared statements but are still not protecting yourself from sql injections.  don't use $_post in the prepare().  you are supposed to bind those after you prepare the statement.
32326	php internally uses the equivalent of serialize/unserialize when you put objects inside $_session, so as long as you obey the rules (don't try to serialize resources, provide class definitions for unserializing) it all works automatically as you have already seen.
32360	just a sidenote: mysql is deprecated, i would advise using mysqli or pdo
32616	the mysqli_connect() needs to be told what database you want to connect to. remember mysql can run 100's of databases simaltaneously.
32695	it would be helpful to clarify how this isn't working.  my initial suggestion would be whether you have session_start(); included on all the pages where $_session is utilised.  without knowing further what is not functioning it's hard to suggested anything further.
32702	sessions are not shared between servers. if you are passing a user with a session on one server to a page on another (where you would like to persist the session) you will need to develop a method of handing that off. preferably with a token and encrypted serialized $_session which can then be authenticated and loaded.
32806	edit: if you are using mysqli, you can do it in the following way, since mysqli doesn't support arrays as execute() parameter (thanks to jeff in the comments).
32879	sizeof is an exact alias of count. count() can only return the number of items in an object if the object interfaces with the countable interface which an undefined variable does not which is causing the error.
32996	the database usually returns an error if data could not be stored. when using pdo you can do it like this:
32998	you can safely put a header()-redirect in the dosomethingwheninsertwassuccessful() function. unless your application writes any output beforehand, there is no reason why this would not work.
33003	note that isset() will return false if the key exists in the array, but its value is null.  something to watch out for if you want the "set" class applied even if the value of $short_list[$result['code']] is null.
33016	in php you must need to start session using session_start() then only you can user session variables.
33082	don't use double quotes in sql queries, they don't work.don't store display logic/styling in your database, you'll have one helluva time trying to change the color from green to notgreen in the future. hell, that should be in a stylesheet, not inline.don't use mysql_* functions, they're deprecated. learn pdo or mysqli, you're doing yourself a disservice by not doing so.your data needs to be properly escaped and/or paramterized.
33097	it's a tradeoff.  if the array is small enough, iteration will be more efficient.  but as the size of the array grows, it will becomes increasingly slower (and hence the function call will become faster).
33908	you're also open to an sql injection. use a prepared statement.
33909	add error reporting to the top of your file(s) which will help find errors.
34156	you're missing session_start(). it must be at the top of any page using sessions. it must also be before any output.
34237	don't use mysql* functions, they're out dated and dangerous, use mysqli* or pdo instead
34692	as mentioned in the comments, you should be using prepared statements to protect you from mysql injection. on your line:
34717	you can exploit a lesser known feature of array_keys(), which is used to return the keys of an array as a new array (i.e. without values.)
35225	pdo (and mysqli) bring prepared statements and parameter binding which is far superior to query string concatenation (which is what you're using, sort of).
35470	also, a better way to display the contents of your array is with print_r or var_dump. these will display arrays within arrays while a simple echo will not.
35509	add error reporting to the top of your file(s) which will help find errors.
35546	if it can be output to a user, you must prevent the potentially malicious user from including html tags in his code. for example, if, in that post, i could include a script tag, that could be very dangerous for any user reading my post. to prevent this, you want to use htmlentities :
35547	now, if you want to save my post in your database, you must beware of sql injections. let's say you're saving my post with that query (yes, you shouldn't use mysql_* functions as they are deprecated, but that's just to explain the idea) :
35588	also, your code is susceptible to sql injection. you should escape any user input that is going to be used in a sql query. try wrapping mysql_escape_string($_post['value']) around all $_post, $_get, and $_request input.
35616	session_start(); shouldn't be in your if condition, it has to be at the beginning of the script and always launched
35634	also as a side note, you should use mysqli instead of mysql
36055	you have to remove the quotes around the variables. use htmlentities to convert all applicable characters to html entities
36346	mysql_real_escape_string() should make sql injection attacks less likely however, it is strongly advised that you use the mysql database apis that are not deprecated such as mysqli (mysql improved) and pdo, which have stronger security in place.
36500	pps: you should know that you're using the ext/mysql functions, but these are deprecated.  if this is a new application, you should start using mysqli or pdo before investing more time into using the deprecated api.
36638	sidenote: learn about prepared statement because right now your queries are susceptible to sql injection. also see how you can prevent sql injection in php.
36749	unlike a cookie, the information is not stored on the users computer,it's stored on the server.
36881	sometimes you're writing xml data, and you can't use html entities in a xml file.because htmlentities substitutes more characters than htmlspecialchars. this is unnecessary, makes the php script less efficient and the resulting html code less readable.
36884	htmlspecialchars () does the minimum amount of encoding to ensure that your string is not parsed as html. this leaves your string more human-readable than it would be if you used htmlentities () to encode absolutely everything that has an encoding.
36971	i would recommend to go to updated and newer mysqli as mysql will probably disappear in some time from php at all.
37306	if you print_r your $_post['fan'], you will see that this is array. to get every value of array you should iterate over it, with for or foreach:
37494	and pathinfo is probably better to get the file name extension, so:
37502	the other good news is, php got a builtin function to search whether a value exists in an array of values (in_array):
37514	aren't you trying to see if the key exists at all? if so, you may want to use array_key_exists, like this:
37572	p.s. you should mysql_real_escape_string each value in $_post['interest'] to avoid sql injections.
37941	side note:you should be using either mysqli or pdo
38144	please read mysql functions manual ant php.net. also don't use mysql extension instead use pdo or mysqli.there are numerous things that are wrong with this script. first of all this $codigo= mysql_insert_id(); does nothing unless you have insert query before that. also, main reason that this script doesn't work is incorrect usage of mysql_fetch_assoc, this function returns associative array so you have to address to the value by key to get it. like this $email=mysql_fetch_assoc($pesquisa)['mail'].yet again i recommend you to use proper mysql extensions and to find proper guide on mysql in php.
38156	you're sending a json string. php doesn't decode that data and map it to the $_post super global automatically. if you want php to do that, you need to send the data as application/x-www-form-urlencoded (ie similar to the uri of a get request: key=value&amp;key2=value2).
38202	fyi: please, don't use mysql_* functions in new code. they are no longer maintained and are officially deprecated. see the red box? learn about prepared statements instead, and use pdo or mysqli - this article will help you decide which. if you choose pdo, here is a good tutorial.
38593	php's built-in file function can get file contents into array. each value in the array is the corresponding line in the file. explode each line into an array based on the space delimiter. this is the code you might be looking for:
39396	add error reporting to the top of your file(s) which will help find errors.
39506	you should start looking into switching over to either the mysqli_ or pdo api and with a prepared statement.
39930	autoloading is by far the preferred way to deal with includes.
40158	try avoid using $_request for things like sending e-mail.you would think that a form has to be submitted in order to send a mail.but with $_request, you can also open the page directly, as in domail.php?your_name=somename&amp;your_email=someone@example.com
40412	please, don't use mysql_* functions in new code. they are no longer maintained and are officially deprecated. see the red box? learn about prepared statements instead, and use pdo or mysqli - this article will help you decide which. if you choose pdo, here is a good tutorial.
40423	to actually check if there are any results, it is better to use mysql_num_rows as it will return number of rows for specified query. so update your code with this:
40475	if you want to know whether the array is defined at all, use isset($array).
40476	if you want to know whether a particular key is defined, use isset($array[$key]).
40490	your question indicates that you know this already, and are wondering if there's a reason why you would do it anyway.  the only thing i can think of is efficiency: if you're going to be checking a large number of keys for existence in an array, you can save some work by first detecting when the array itself isn't set, and just skipping all the individual key checks in that case.
40598	regarding your second question, pdo protects you against sql injections. you still have to escape html before outputting it, to protect from js code injection
40599	note: in_array performs a linear search of the array contents, which might not be the best way to go if one or more of the following conditions are true:
40605	at the start of each page, you should have a call to session_start();. then, simply assign the values for your cart to session variables like so:
40606	then (when the user places the order) you would scrub the input, to prevent sql injection, and add a new sql query, perhaps something like;
41042	you don't need to use htmlentities before storing data in the database.  in fact, it makes things easier later if you don't.  only use htmlentities on strings as you echo them in html output (whether you fetched the string from a database or from some other source).
41106	if you just want to protect you from sql injections, use mysql_real_escape_string for data that is used in mysql queries. you could also use prepared statements or parameterized query builder (see sql syntax for prepared statements, pdo – prepared statements und stored procedures, mysqli::prepare, et al.).
41339	use prepared statements and parameterized queries. these are sql statements that are sent to and parsed by the database server separately from any parameters. this way it is impossible for an attacker to inject malicious sql.
41346	for escaping special characters in sql statements.don't use mysql, this extension is deprecated, use mysqli or pdo.
41356	seems like you forgot session_start(); on top of the code.also, you cannot have code after the header("location:$url); you need to move the update statement prior to this function and add an exit; after the header function.
41357	this (mysql_*) extension is deprecated as of php 5.5.0, and will be removed in the future. instead, the mysqli or pdo_mysql extension should be used. switching to prepared statements is even more better to ward off sql injection attacks !
41377	you have to add &lt;?php session_start(); ?&gt; on the top of every page where you'd like to use the $_session[] variables.
41408	you need to have a try block before you can add a catch block. you will need to change your code to something like this:
41507	ok i solve this problem. the problem is codeigniter does not accept array of pairs when unset session data. i.e
41783	you might also want to have a look either at pdo and prepared statements that replace mysql_ functions.
41916	possible it is missing the call for session_start, session_register make this automatically, so what you have to do is just make sure that you have called session_start before use $_session global.
41917	add a session_start() at the begining of your code and $_session to manipulate it or create it.
41928	you can use this code..dont use mysql and mysqli combinations.
42060	basically, every page will start with session_start() to initiate the php session.  after that, you have access to the global $_session[] array which you can use to store and read data.
42161	you can also use str_replace which should be faster then preg_replace, according to this entry. which would be something like:
42344	looks like $this-&gt;updates is not empty but its not an array. you can use the is_array test before you use it in foreach:
42901	joining up raw bits of text and passing them on to your database to process is not a good idea. it opens up your system to sql injection. while it's unlikely that someone could compromise your site when only insert statements are exposed in this way, it does mean that:
42903	regarding the sql injection problem, there are 2 methods to protect your system - one is to transform the data in which a way that it cannot break the sql string it is added to (e.g. using mysqli_real_escape_string()) but the recommended approach when using pdo to mediate your code's interaction with the dbms is to use variable binding. here you compose your sql command with placeholders for the data and substitute them at run time.
42906	sending it in a round trip to the browser, as a cookie or as form variable means that it could be tampered with. there are esoteric stateless solutions where you can do this but with the data encrypted or cryptographically signed,  however the simplest solution is to use sessions - add session_start() at the top of all your pages and any data you want available across requests can be stored in the $_session superglobal.
43052	put session_start(); at the top of your php file. then when they successfully log in, you can do this:
43057	the alternative to mysql_escape_string in pdo is using prepared statements. in yii for example:
43058	you are secured you against sql injection when you pass parameters through placeholders in a prepared statement.
43183	a cleaner and more professional approach to block ip addresses is not possible on many shared hosts, but should be mentioned here anyways, because it saves bandwidth, memory and cpu-cycles and can be described as dynamic creation of firewall rules. there are tools like fail2ban helping to overcome compatibility issues between different firewalls keeping your php application portable between root servers. fail2ban can scan all kinds of log files, even custom ones. your php application could just write to a log file and fail2ban would disallow any connection attempt from that ip address to your server. sounds cool? root servers ain't expensive nowadays if you would like to try it.
43218	by storing your data in the $_session array you will have access to that data in every php script the user accesses.
43220	in order to have access to the session array you must call session_start(); before accessing the $_session array.  remember to only call session_start only once per php execution.  if session_start is called multiple times is will generate a warning or an error (i don't remember which)
43221	you can check if the $_session array is set to know if the session has been started
43462	also please stop using the old mysql_* functions. use either mysqli_* or pdo. mysql_* functions will be deprecated in the future.
43466	alternatively (and for your own good), you could use parameterized queries with pdo or mysqli.
43618	using pdo with prepared statements will take care of escaping your inputs :
43688	also, i hope you sanitize your _post inputs properly so little robert won't be able to harm your database.
44312	then you can use session_destroy(); to end their session. this will destroy their entire session.
44313	otherwise you can use unset($_session['user_id']); to unset a single session variable
44330	ajax calls in an interval will put extra load on server. if you want real-time response to your actions(e.g. the user will be signed out right when you ban them from your system backend), then you should look into something like server push.
44392	what's going on is when you're fetching your rows from mysql, you're essentially getting a bunch of data in an array in the first place, which is why you have to loop through them.
44415	if you just want a list of the names of the variables, just do var_dump(array_keys($globals)).
44532	but i have to mention that naming the variable should be done better to avoid confusion. make some effort in naming the variable to decrease the errors in your code.also you have to use another way for connecting and querying the database.the mysql extension is deprecated and will be removed in the future: use mysqli or pdo instead
44674	you can only replace the html's body element with php if you are outputting the html with php (changing it before outputting it). php works server-side, so once the html reaches the client it cannot modify it.
44676	to change the id of the body dynamically using jquery (which is the easiest way), you can do
44737	in php, casting any string that doesn't begin with a number evaluates to to 0. the 0 exists in your array, so in_array() returns true. if you don't want this to happen, set the third parameter for in_array() to true, so it performs a strong comparison (equivalent to ===) and consider the types, too.
44807	var_export will output the string representation of the value, instead of the type / value combo var_dump returns.
44845	you shouldn't use mysql_ functions anymore, they are deprecated, and unsafe (for sql injections),you should have a look at mysqli functions or pdo, personally i recommend learning pdo, as the queries are parametrized and it's very safe, and i like the logic and readability you get with it. links:
44894	well, like the people asked in the comments; what is it that isn't working?i'd also suggest you use mysqli instead of mysql.
44897	if you still want to use mysql, just change "mysqli" to "mysql" and edit the connect along with the query.i would help you with your code but as you didn't really point out what's wrong i'll simply give you this example. :)and as others also said; you should get familiar with how to prevent sql injections.
44945	though, there is other problems, your query has 0 protection from injection. and these days it's good practice to use pdo for database connections.
44946	also, while the headers are fine, you need to check on the admin page to make sure they are an administrator. and make sure to hash their password and compare against the hash. also don't store the password in the session.
45026	first of all stop using the mysql_ and mysqli_ libraries.they are dangerously outdated and should never be used because of sql injection issues.
45131	this is injection safe method with pdo, and i recommend you to use it:
45154	you should also be safely binding your user-input values to the queries to prevent sql injection and fully utilize the pdo library
45219	you could always do var_dump($_get) to see all of the information in the query params for the specific code.
45328	you could use print_r(). that will print the entire array with the keys and values.
45702	$_post, being a superglobal, is always set.  you may want to check if a certain key is set (if(isset($_post['foo']))) instead.
45836	no, it shouldn't.  array_key_exists checks for the existance of keys, not values.  your $uploadpriv_ass array's last key is 4, and you're passing the value of 5 to array_key_exists.  since $uploadpriv_ass[5] is not set, you're not getting the "t".
45968	you can "salt" the hashes with extra data so if they are compromised, it's value cannot be found (try googling some simple hashed words).. i.e. use a site-wide string just to alter the standard hash like md5("mysitesalt!!" . $_request['pass']); or something more advanced.
46050	then, you have to switch to new mysql syntax for php, like mysqli or pdo. the mysql syntax you are using is deprecated.
46072	that said, you should really consider both switching two either pdo or mysqli for your queries rather than the mysql extension and also looking into prepared statements and properly sanitizing strings, because you're very vulnerable to sql injections.
46133	as someone said in updated version of php mysql_* function are deprecated you can use mysqli_* functions, your code is not working because you have closed your mysqli connection in mysql.php
46147	isset() returns either true or false if the post variable exists or not. it does not return the variable value, the you need to add another check in your condition :
46376	remember to use stripslashes() to remove the quote escape on the values use addslashes() on.
46428	post variables are passed via the super global array $_post in php. so in your case, this would technically work:
46626	your browser converts the literal space in urls into a + sign - before sending a http request. when php sees that very + sign, it will become a space again for $_get.
46703	additionally, look into using the mysqli library (or similar) and learn how to parameterize your queries so you can avoid dealing with sql injection later.
46945	i'd use isset() instead to properly check if the form was submitted or not.
46948	you shouldnt use the mysql_* functions in php anymore as they  have already been removed from php7 and will not return from what i understand.
46956	you call session_destroy()  the user deletes the cookie from their browser the session expires based on the session expiration time defined in php.inia new page is visited but the session_start() command is not called (once session_start() is called, then the session will be restored, bringing any $_session[] variables along with it)
47121	if you're a beginner, please don't put effort in deprecated language-parts like the mysql_ extension. learn to do it right, just from the beginning. use mysqli or pdo with prepared statements and bind your inputs to parameters.
47151	if you have to allow users to input arbitrary html, it's going to need some processing. unless you really trust those users, you'll need a purifier (to stop them using dangerous scripting elements and xss-ing each other), and a tidier (to remove malformed markup either due to crap rich-text-editor output or deliberate sabotage). if you intend to put the content directly into xml you will also need it to convert to xhtml output and replace html entity references.
47268	but a better way would be, when you would prepare your sql string before you execute it. have a look at php pdo mysql connector. there you have some methods to prepare your string.
47308	this is using procedural style and the mysqli extension. do note that you are using mysql which is deprecated so it is recommended to switch to mysqli
47331	when you try to echo an array an implicit transformation from array data type to string data type is performed. because only strings can be echoed.
47332	if you want to see array contents - use print_r or var_dump, for example.
47337	you can add the 'i' modifier in a preg_match pattern to do a case-insensitive search.
47584	do not use extract.  it is bad practice to use it generally, but especially on a _get variable...it opens you up to a dos attack where someone can flood your query string with hundreds of unneeded variables.
47628	there are a few solutions here.  one is to use array_values to re-index the array:
47735	you have wrong order of arguments. however, using mysql_* is highly not encouraged. it is an obsolette database api with a lot of vulnerabilities. switch to mysqli or pdo instead
47976	secondly as far as i can see there is no reason for you to wrap mysqli to begin with. what do you gain by wrapping an object like that. mysqli comes with an object-oriented interface out of the box.
48024	please note: this is extremely unsafe! you need to sanitize all user input before using it. my example above, dis-regards security, and simply is to demonstrate my point. get and post data, are user variables. a malicious user could put bad code in the url (ie ?name3=&lt;badcode&gt;) and it would be printed on the page, well in the source code, which they could easily pop out of. also, in sql queries, you need to escape the data or use prepared statements.
48025	you should not be using mysql functions, switch to mysqli or pdo. mysql has been killed for a while now..
48028	you would use mysql_real_escape_string() on them, but you should be using mysqli or pdo anyways...
48174	apparently my answer below didn't work as you expected and even got a down vote, but it should work. maybe not if you just copy and paste it, cause i might have missed something in the rest of your code, but the principle is there. use mysql_fetch_assoc to get an associative array which will include the column names as keys. loop over the array and check the key for the special cases you want to handle differently.
48202	if you are looking for looking_word parameter in $_post variable, you won't get it as its part of a get request and will be available in $_get. if you want to make it general you can check $_request variable.
48208	passing arguments via the url sets them to $_get not $_post to set data to $_post you have to post data via an html form, curl etc
48347	this will get you the keys. if you need the keys from each result just loop over $results and for each $result get the keys, using the array_keys syntax.
48401	don't insert $_post data to the database directly. you should use validation to implement data security.
48404	use either $_server['http_referer'] or have a hidden post value sent with the form to identify the page or form sending the data.
48692	the entire mysql_query api has been trashed, it's obsolete and the latest version of php no longer supports it. you need to move on to something better, and i'd recommend pdo as a baseline.
48695	with pdo you can name your placeholders. this makes executing your statement later very easy, you just match up the values:
48696	so the best way to avoid injection bugs is to avoid injection in the first place. placeholder values will be substituted correctly, safely, and most important, consistently. all it takes is one mistake where you thought you escaped something but you didn't and people can bust your site wide open.
49043	i also will note that you should use prepared statements with pdo or mysqli as it is better protection than using mysql_real_escape_string.
49070	also, header() doesn't work if you've already produced output. you should move the block of html at the top to the else clause of the if ($_post) test.
49085	some notes on the use of glob(); for opening files in case you may not be opening local files (it won't work on remote files):  http://php.net/manual/en/function.glob.php
49364	it looks like somehow your header is getting sent no matter what.  without looking at the rest of your code i cannot be sure, but print_r, echo, or any other type of output before the header would cause it to not be sent.
49491	note that you shouldn't be using mysql_* functions since it is a deprecated library. think about making the move to mysqli_* or pdo.
49492	having said that, your query is incorrect. you can't use values() and a selection together in an insert statement. you should instead, select the string literals you are trying to insert along with the one value you'd like to select.
49502	then check your logs if you get some errors. its possible that you have an error before the header command. that causes an error because you have an output before the header is send and the image is not shown.
49584	your $con isn't set inside your function, so mysqli won't work. additionally you're using backticks around the value you're searching for $_session['user_id'] backticks are for column names, you should use ' around values.
49716	suggest you to use pdo http://in1.php.net/manual/en/ref.pdo-mysql.php or mysqli extension because php 5.5 wont be supporting mysql extension any more
49938	do not use mysql functions, because they are deprecated. use mysqli or pdo instead.avoid sql injection by escaping your variables.
50104	please stop writing new code with the ancient mysql_* functions. they are no longer maintained and community has begun the deprecation process. instead you should learn about prepared statements and use either pdo or mysqli. if you cannot decide, this article will help to choose. if you care to learn, here is a quite good pdo-related tutorial.
50173	to pull your images and pictures from your database, a select query is what you are looking for. fetching them shouldn't be an issue since there is almost nothing to fetch if you precisely query the required information. you might need to loop through your result, however.
50176	you should also consider using mysqli since mysql_* is now deprecated.
50234	your session_start(); should come at the beginning of the file in login.php. i see you using $_session[custno] before it's called. that's why your textbox is empty.
50235	you should use quotes in array index :$_session[custno], $_session[name] should be $_session['custno'], $_session['name']
50276	note: you may need to call bind_param() after setting the input variables rather than before. i can't remember how mysqli parses them and when they're bound, but logically it makes more sense in code to set them first then bind anyway.
50297	also, incorporating potentially unsafe values (such as values of variables from a $_get or $_post) leads to sql injection vulnerabilities. values incorporated into the text of a sql statement must be properly escaped.  see mysqli_real_escape_string. but that's not sufficient to guarantee that code isn't still vulnerable to sql injection.
50304	you could muck with escaping the values, but a much better pattern is prepared statements with bind placeholders...
50322	correct or not, you can do it easier and safer. one of the main advantages of pdo is the support of parametrized queries, where you only write placeholders and let pdo insert the values. this will help protecting against sql-injection, because pdo will do the correct formatting for you.
50395	php 7 has removed mysql_* completely. use pdo or mysqli
50401	1) modify the code to remove references to the mysql extension (and use mysqli or pdo instead), or
50435	also, $_post is an array. which is why you need to specify the key, in your case ['value'] is your key. now you can also echo out the entire $_post if you want to see other values it holds, but then echo does not work on arrays, so you will need to use print_r($_post);
50623	explode returns an array where all the items from the string are values and the keys are just numbers starting from 0. take this example:
50631	if you want to find out if a certain value exists in the array use array_search().  or in your case, since you're running your list through array_count_values() which is going to convert your values into keys, you could do a normal isset() lookup on the $values variable after running the function.
50643	and yes, you can put array in array. also you can put next array into that array :) it's called multidimensional array.
50710	it should be noted however @objective_d - you ought to use either mysqli or pdo as they offer far greater protection from the dreaded sql injection by utilising prepared statements. good luck - happy xmas
50841	php is kind of interesting in that it doesn't pull from $_post like other forms when ajax is involved. you actually will need to read the input from php://input
50842	edit: you can add the filter_var command to strip bad characters and sanitize the input.
51093	yes, since you’re putting it out into html you should use encode html’s special characters appropriately with htmlspecialchars:
51259	in php you can use implode funciton, which lets you concatenate array items with the glue string (as first parameter) php (result.php):
51358	also, you should use mysqli or pdo instead of mysql.
51388	be sure to remember your session_start(); at the top of each page that uses the $_session variable.
51547	first of all, using get for sensitive data like email/password is a general no-no. bad practice all the way.
51586	also, your present code is open to sql injection. use prepared statements, or pdo with prepared statements, they're much safer.
51588	add error reporting to the top of your file(s) which will help find errors.
51597	to make the pattern more clear, the code example above doesn't check the return from the prepare or execute. we'd really want to check if the return from prepare is false, we don't want to call bind_param or execute on that.
51601	the use of htmlentities assumes that the contents of the review column does not contain any html markup that should not be escaped/encoded.
52021	and for sure you have to call session_start() at top
52061	you can't compare a scalar variable to an array. you need to us in_array() here:
52563	consider using mysqli_ functions or pdo and protect your code against sql injection.
52599	totally safe. the pdo statement prepares the query to avoid sql injections. even if they try, the prepare() function make the necessary changes before send to the database.
52723	empty() returns true if the values is a empty string, while !isset() will return false.there are many questions about this, for example look here.
52753	also, the mysql_* extension is deprecated as of php 5.5 and is due for removal in future releases. it's recommended to use mysqli or pdo instead.
52770	you have to use session_start() at the top of all your html sites, otherwise you loose reference to the session and to all its stored variables.
52790	sidenote: i've noticed you're still using the deprecated mysql_* extension. please discontinue the use of mysql_*, it is no longer secure or safe to use, and there are much better alternatives. i would suggest mysqli_* or pdo.
52849	first of all, do not use the old mysql_... functions. i recommend you pdo, but if you want it the "oldish mysql-style" at least use mysqli. also, since i assume you are not familiar with the security procedures, read about sql injections.
52988	you need to check the return value of pdo::query(). in (ugly) php there are lots of functions that return a value of mixed type. in the case of pdo::query() the return type is either pdostatement or bool, although the prototype in the documentation says something different:
53506	also, just for the sake of clarity, you are using $_post data directly in a sql query without sanitizing or validating the data. i realize this is for practice but it should be mentioned that this methodology is highly vulnerable to sql injection and will make your database easily accessible. you could, instead, use php's pdo library for your connections or at the very least sanitize your inputs.
53643	if you are really sure that your code works (even if this is a bad example), use error_reporting(e_error); to remove notices.
53645	you'll also want to add session_start(); to the top of the script.
53649	an undefined index error is issued when you are trying to call an index of an array, when it is not defined.for example:
53650	always check the existence of a key in an array before trying to call it:
53651	ps: i noticed that you're using mysql_* functions, which are deprecated. try using pdo instead.
53898	the problem i was having was that if you check to see if a field in the form isset it will always be set once the submit button has been pressed.
53899	if, like me, you want to check if something has actually been entered in to the field then i would say you need to do an if(!empty) check.
54041	or even better drop the mysql_ lib (it was depreciated 10 years ago!) and use pdo.
54163	you should also at least use htmlentities on the value that an input won't break your html:
54167	note that i have used htmlspecialchars to avoid your variable breaking the html. you also don't need to use parenthesis when you use echo (doesn't harm though...).
54257	the dsn specifies (amongst other things) the hostname and database, using host and dbname elements respectively; whereas authentication credentials are supplied as subsequent arguments to the pdo class constructor:
54491	also, note that mysql_ functions has been deprecated and used in the wrong way can be very dangerous, leaving your website vulnerable.
54503	also, in your example, you're using mysql_ functions, which have been deprecated in later versions of php5 and removed in php7. best to study up on mysqli_ or pdo (which you can also use with mysql databases).
54648	advice: avoid using mysqli_* statement as they are deprecated in recent php versions. learn mysqli_* prepared or pdo and start implementing.
54809	alternatively, you can use $conn-&gt;exec($sql), which works regardless. however, it will not allow you to bind any data to the executed sql.
54837	you should also correct your php to avoid sql injections. try to use mysqli or pdo
55234	the problem with $_request is that if there are variables of get, post and/or cookie, one will override the other in that superglobal. it's semi-predictable what values you end up getting if you try to access $_request.
55237	no, it's not bad practice. the only thing is that $_request will contain values passed in get and post commands, and cookies values. so if you want to process only values passed in the url, you will probably want to use $_get...
55415	it's from php manual. you can set the value in $_cookie array by manual if you really want it in same page which's declared.
55558	just adding this since i didn't think it was clear, but the problem is definitely your production version of php. persistent connections for the mysqli extensions weren't added until 5.3 since they caused headaches before.
55722	second, you need to check for errors after every prepare() or execute():
55744	i noticed that you're using mysqli to connect db, then you're using mysql for  execute query, you should use same lib, try to execute your query through mysqli_query()
56094	also in your form you need to have value so there is data to get:
56097	along with this as @bhttoan pointed out. you need to make sure you are doing mysqli for all your functions and not mysql interlaced with mysqli.
56273	even if you have used pdo, your code is still vulnerable with sql injection because you have not parameterized the query, query must be parameterized in order for the values to be cleaned.
56543	is it possible you're "double encoding" any existing &amp;nbsp; parts of the string?  you call htmlentities on the string before html_entity_decode, so any existing &amp;nbsp; characters would become &amp;amp;nbsp;.  you can prevent htmlentities from double encoding by providing false as the fourth parameter.
56545	also, bare in mind that you can pass an array for matches in str_replace:
56569	if you are using php and mysqli, then mysqli::real_escape_string() will help.
56571	if you are using session_start(); correctly (at the begining of your document), your code is fine.
56580	prefer the international language for programming. (even if you love you mother tongue, i understand) this is more understandable and re-usable.prefer pdo to old obsolete mysql_* functions.if you persist, please use mysql_fetch_assoc() instead of mysql_fetch_array(), this is lighter and you get what you want.look at one of the million tutorial on the web to learn basics. (look at pdo, include, post and framework keywords)
56650	mysqli_real_escape_string() is possibly doing the "escaping" as you require, however "is adding slashes to my text" is not what mysqli_real_escape_string() does. don't expect it to modify the code, or add backslashes. it just escapes chars when adding to the database.
56790	also try removing the mysql_* functions and using mysqli_* functions or a pdo because the mysql_* functions are depreciated.
56977	way to treat them: how can i prevent sql injection in php? tldr: prepared statements are king.
56982	(+) there are libraries like htmlpurifier which allow you to only sanitize specific elements. so if you want to let your users use html for a blogpost or whatever, you can a library like this which will allow certain elements and defuse the dangerous stuff.
56984	way to treat them: escapeshellcmd + don't use user input for something like directory or filenames on your server! put the names of the user into the database, use the id or a hash or something you generated as the filename.
56993	when saving data you worry only about the charakters which might break the syntax of your sql. your database knows best which charakters to escape and how to treat which data, so just use the escaping and quoting functions provided by your database-api or better: prepared statements (just use them always when interacting with the database + userdata) as they work differently then normal queries and you don't have to think about escaping and quoting.
57025	and lastly you shouldn't be using mysql_* you should use pdo or mysqli.
57036	leave a placeholder in the query where you want to substitute the dynamic value.  you can use either positional parameters with the ? symbol, or named parameters with the colon-prefix syntax.
57292	as explain in the docs, array_unique compares elements as strings by default. you are getting this error because php is trying to convert an array to string. you have a 2d array, an array of array.
57402	first, you are mixing the mysql api's at somepoint you are using mysqli_* at some point u using mysql_* they don't mix. and mysql_* functions are depreciated they no longer supported by later versions of php. better use mysqli or pdo. this mysql_real_escape_string() or  mysqlo_real_escape_string() is not safe enough to prevent you against sql injections. solution is simple better start using mysqli prepared statements or pdo prepared statements.
57625	note: stop using deprecated mysql_* versions. there are better alternatives likes mysqli or pdo
57802	can use array_key_exists() to check key exist or not. no need to use nested foreach() . example:
57933	use isset when it's important to know if the variable has been defined and is not null:
57934	use !empty when it's important to know if the variable has be defined and is truthy
57937	use array_key_exists when it's important to know if the key exists and the value is of no importance:
58063	use mysqli instead of mysql to prevent hackingand also validate the user input use htmlentities() or htmlspecialchars()
58126	if the query returns no rows, $row will be null. so you will need to check for this.note that you do have a potential sql injection vulnerability by passing $clear and $useridentity directly into the sql query. for $useridentity, you should use parameterized queries (which means you can't use mysqli::query(); see mysqli::prepare for an example of how to do this). since $clear is used as a column name, and you can't parameterize column names, you will need to take extra care to ensure that it is valid.
58129	i'd say it is not a dead end but on purpose. filter_input() requires you to clearly specify the input type. $_request is not clear about it, it contains input from various sources, allowing one source overwriting another.
58136	the reason why you must use array_merge and not array_unshift is because the latter only works on numerically indexed arrays.
58143	note: when using array_merge the items with the same keys from the second array will overwrite the ones from the first one, so if 'front' already exists in $queue it will not be overwritten, but only brought to the front. on the other hand if you use +, the new value will be present in the result and be at the front.
58183	session_start() will need to be included to all the pages where you either want to store the session values or access them.
58203	this is why you should be calling session_start() for all requests, and why if should be one of the very first things in your script. personally, all of my projects have the same 2 lines at the beginning of the global header:
58345	the mysql_* functions will work, or better is mysqli, or even pdo etc.
58456	you are using explode() on an array. explode is used to create an array from a string. you do not have to do this, please refer to the manual http://php.net/explode to understand. change the lines below
58509	preg_match() can only accept strings as pattern. there is no reason for it to support arrays, since a single regular expression pattern can be made to match all those characters.
58640	pro tip: avoid using select * in production software. instead give a list of columns you need. your software will be more robust and easier to understand if you do that.
58708	firstly, please use something like pdo or mysqli's prepared statements.
58731	but first; as others have pointed out and it's been said time and time again, the use of mysql_ is being deprecated and will be deleted in the very near future. therefore using mysqli_ and/or pdo is strongly and highly recommended.
58750	i didn't test your code but i think it's because the session is not started yet when after the signs up. try adding session_start(); in the first line of your first code.
58782	isset is the proper choice here -- empty is only intended to examine a known variable to see if it is "emptyish". according to the docs
58790	you should have a look to foreach() learning to loop through arrays. also have a look to empty() and isset()in the php documentation, those are your first friends for validating.
58924	so, to make this work you have to use either __dir__ or dirname(__file__) to find out where your script is located in the file system.
59120	array_slice() always returns an array - if there are no elements to return for its given offset, array_slice() returns an empty array. so, for each recursion, we want to:
59184	those values are telling pdo how to treat the input, not to disallow input. if you send text, but the column is int then mysql will attempt to coerce the data into int. it won't tell you "you entered abcd but expected value was integer". you must do this check on your own before passing data to pdo.
59185	don't use bindparam. bindparam accepts the value by reference. this is intended for when you invoke stored procedures and variable is supposed to be modified based on procedure's output. use bindvalue. if you tried to do the following with bindparam, it wouldn't work and you'd get an error:
59255	cookies do not work that way. when a cookie is set, it is not available (i.e. a corresponding $_cookie key exists) until the next request.
59257	@[niet the dark absol] is correct that you cannot interchange mysql_ and mysqli_.
59478	get is a super global variable and to access it you have to use $_get.
59662	you should probably take a look at using a library like pdo for your database queries as you're really exposed to injection attacks.
59684	it's a design decision. you'll have to ask the developer who wrote it.the $_session array stores everything you throw at it. you use it like any other php array and it will be stored for following page loads. there are not any predefined session variables (try doing a var_dump($_session) if you want to check for yourself).yes, you can mix as you wish. "arrays" in php are actually hash maps, and each element may be any other php datastructure (including other arrays/hashmaps). so it's not really a multidimensional array, it's a hashmap storing other hashmaps.
59685	well let's say you have a bunch of possible messages, not just alogin error. then you would want an array of messages to iteratethrough. hence the msg array.session variables are useful for persistent data. you usesession_start(); at the beginning of each file that you want toaccess the session, and you can retrieve that data again. i don'tknow of any pre-defined variables, although i don't see why you'dreally need them.can you clarify this question a little more?
59985	also, if you are new to php, i would recommend the pdo libraries instead of mysqli, they are a little easier to work with once you start fetching results.
60104	ps: i think you don't need mysql_both. and also do not use mysql_ functions. use mysqli_ or pdo instead.
60282	isset is used to check whether input you receive contains what you expect - this is a very, very loose definition and i wrote that trying to explain easily when you'd use it.
60290	when you receive an input that user made via html form, you want to check whether certain values have been populated - in that case, you use isset.
60448	note - you are using the old obsolete mysql_* functions rather than the current mysqli_* functions (or the pdo equivalents). i would advise you to swap over. this would also allow you to use parameterised queries which are safer. your current query is wide open to sql injection attacks.
60618	second, the query above gives back a one-row result set. you need to actually read that row. i'm not going to tell you how to do that using mysql_ because only a fool uses mysql_ these days. please, please use pdo or mysqli_.
60695	always use mysql_real_escape_string instead of addslashes. make sure you are connected to the database before running it otherwise you will error.
60716	add error reporting to the top of your file(s) which will help find errors.
60719	make sure your html form does hold a post method and that all inputs bear the name attributes and no typos. using error reporting, will signal that.your present code is open to sql injection. use mysqli with prepared statements, or pdo with prepared statements, they're much safer.
60770	first of all do not use mysql_* as ther are deprecated. use mysqli or pdo instead. the error is here:
60961	however, if you're using this with a get array, then yes; it would be best to use an isset() and empty() on a conditional statement.
61016	you can get the base url using $_server['http_host'] you may need to append http/https to the string.
61017	you can also then use $_server['request_uri'] to get the remainder of the url.
61056	and remember, a get request should be used to retrieve, and a post request should be used to create. in your case, it seems a post is more appropriate (reply).
61063	here's how i would write your query using mysqli. one advantage of using query parameters is you never need to worry about where you start and end your quotes.
61064	if you must interpolate variables into your sql, first make sure you protect the variables either by coercing the value to an integer, or else by using a proper escaping function like mysqli_real_escape_string().  don't put $_post variables directly into the string. also you don't have to stop and restart the quotes if you use php's syntax for embedding variables directly in double-quoted strings:
61091	use array_merge(), because array_push() will push the output of explode(), which is an array, as a whole to the array in the first argument, creating a jagged array.
61093	while outputting to html, you also might want to put a $value = htmlentities(trim($value)); in the foreach loop.
61106	neither of the last two variables are defined - you probably meant $this-&gt;username and $this-&gt;password. you're also probably opening yourself right up to some sql injection vulnerabilities - check out pdo and prepared statements. and if this is for an actual web application, start salting and hashing your passwords.
61216	edit: php 5.4 will support array dereferencing, so you will be able to do:
61226	about auto-commit: in auto-commit mode, each query is a complete transaction and it is executed instantly. by default, pdo auto-commits each query. turning off the auto-commit will need you to commit the query manually. in general scenario, you should not turn it off.
61331	first off, you should avoid using superglobals like $_post within your class. a better way is to inject the $_post from the top level and just treat it as an array. it makes your class more generic and flexible.
61346	you can use isset function to determine if a variable is set and is not null.
61352	you can also add an @ before a variable when you want to use it but you can't be sure it exists.  this will suppress warnings about the existence of the variable, but i think it's better to know what the default value should be.  sometimes it's useful to get those warnings.
61514	when you are manipulating urls, you should use instead urlencode to send your content as parameter of the url.
61515	as the documentation says, urldecode is not requiered because the superglobals $_get and $_request are already urldecoded. so, in your script which do the job you can directly use the value in your $_get entry.
61633	you probably need to wrap each set of &lt;input/&gt;s in separate &lt;form/&gt; tags. if php sees more than one input with the same name, it just takes the last one. for example...
61815	for more security use prepared statements.and check if $_post['username'] and $_post['password'] are set too (even if your input fields are "required")
61838	the error suggests that select() is called on a null object. do a var_dump() on your parent::$db and make sure that the object is not actually empty.
62057	you probably want to call session_start() before the $_session variable will be available.
62207	you should be using php pdo library http://php.net/manual/en/book.pdo.php or at least mysqli http://php.net/manual/en/book.mysqli.php
62339	the error message is quite clear. mysqli_query() requires two parameters. you only provide one. when you see an error message like this the first thing you need to do is go to the manual. if you did you would see you must provide your mysqli link as the first parameter:
62520	it is possible to lookup for more than one string with str_replace like:
62563	the reason is that $_cookie[$cookie] returns the current cookie sent by the browser. while setcookie sends a cookie to the browser. when you retrieve the value $_cookie[$cookie], the cookie is not yet set because it will be set after the page is requested.
62596	you should start session before any output.change your code to:
62676	you can't use mysql functions with a mysqli connection, and vice versa.
62723	an array could be really helpful when it's a dynamically created form. a form where the number of inputs is not set, for example a contact form where you can click on a plus icon to add another text input for multiple phone numbers. bacause its unknown how many phone numbers someone have its easier to just retrieve one variable as an array and iterate over this array after.
62758	if you do not want the webpage to load, when submitting, you'll need some javascript.
62869	unless you specify when the cookie is to expire it will automatically expire when the browser window is closed. the third parameter of setcookie() allows you to specify the expiration of the cookie:
63070	to add another value of an array is to use array_push and to delete it you can use unset. see the example below.
63147	you can use (in_array) function to check if var in array or not
63210	note: mysql_* functions are depricated, use mysqli or pdo as an alternative.
63211	it means that $_post['f_child_cat'] is not defined (doesn't exist). you should be using binded parameters to prevent against sql injection and use mysqli_ or pdo functions.
63246	and finally: as people said in the comments, stray away from mysql_* functions, and look to sanitize the data going in and out of your database.
63314	make sure you do similar escaping for all of the input you're using in the query.
63429	since you are using pdo(a very good job there =) ) you can't call mysql_* functions.
63430	you need to pass pdo::fetch_assoc as parameter to be able to retrieve the data using named indexes.
63670	furthermore, i don't think you should be adding slashes to the content and directly insert the values in a query, instead consider using parameters. read up on php data objects (pdo: http://php.net/manual/en/book.pdo.php) which is a very nice and safe (if used properly!) extension for interacting with a database.
63678	after header(...); you need to throw in a return; or exit; to exit right there, otherwise it continues beyond that header.
63679	you are open to sql injection in checkavailableusername, you need to sanitize the value before you get to that function and also escape/bind the value to your query instead. it looks like you are using pdo already.
63698	magic quotes have been deprecated for a long time. you shouldn't use it anymore. since php 5.4 it is removed from the language. especially, when writing new scripts you should avoid this abandoned feature.
63800	and since you're using pdo, why not use prepared statements:
64015	session_start must be called before you read from -or write to- the $_session variable. in the second page "error page", you placed session_start but after you tried to read the $_session var, so place it in the top of that "error page" instead of the middle.
64092	updated answer due to updated question :i removed session_destory if you execute that and if you have another session variable ex: user isloggedin it would be destroyed too. unset is ok for the purpose. please check xss, sql injection attacks around the internet implement logic according to best practises, and validate/sanitize your data before process parameters into db or etc.
64129	you must use cookie instead of session. in most cases (it depends of php settings) the session will have limited lifetime.
64153	when you want to execute a query, first make sure it will run by making it not equal or equal to false. that way you can debug your script. try to prepare the query alone instead of executing it right away.
64200	if you're outside of a loop and you want to insert multiple items simultaneously then use array_push.
64256	this happens because when you don't fill anything in the fields, you receive an empty string. this is not the same as null and will cause pdo to convert it to the given type pdo::param_int
64380	you can use the substr function : http://www.php.net/manual/en/function.substr.phpand if you don't know the position of the word, use strpos to get it : http://php.net/manual/en/function.strpos.php
64613	hope that helps!suggestion : try not to use mysql_* functions as they are deprecated now! instead, use pdo. it will save your script from sql injection too!
64702	but you should not use the native interface either way. use pdo to open sqlite databases. http://www.php.net/manual/en/ref.pdo-sqlite.php
64828	please, please, please i beg of you stop now and learn about prepared statements in mysql/php, the pdo system is a good one to use and should be pre-built into your php setup.
64942	so the first thing i'd recommend is to stop using the mysql_xxx() functions, and switch to using the pdo library instead. the old mysql functions are deprecated anyway, so it's not recommended to use them if at all possible, but in this case there's a specific reason for using pdo instead because it has significant performance benefits over the old functions.
64943	pdo allows you to use a feature called prepared queries allows the database to cache queries more efficiently if you to call similar queries repeatedly.
65023	mysql_connect does not return any object .... so it does not have any function or property that you can access using -&gt; operator  . it returns a connection identifier
65024	i advice you to start learning mysqli or pdo since mysql functions are retarded and no longer maintained
65195	php is separate from js, but you can 'echo' to javascript from php the same way you would normally do with html. remember that session_start has to be the first thing ever in your code, as it sets some headers.
65228	also, you should validate your $_post variables (at least use mysql_real_escape_string, better use mysqli or pdo).
65287	if your field is an integer, consider using an int cast (int) before appending the value to the query. do however note that all other variables must be escaped before appending them to the query, because one of them might contain a string that invalidates the query.
65289	__construct and __destruct are called every time a script is ran with an instance of that object.  if you put an object in a session, that object does not hold the same value across page views, it is simply an object.  i wrote a quick example to demonstrate this:
65295	for prevent sql injection first you need filter the input, second use pdo.http://php.net/manual/pt_br/pdo.prepare.php
65303	in one hand, you have the login credentials in the mysqli_connect, that are used to connect to the database. as these parameters are usually used internally, there's low (but yet probable) chance to get a direct connection to the database through sql injection.
65304	in the other hand, $user = $_post['user'] and $passwd = $_post['passwd']; are parameters for a query, which can be subject to sql injection if no validations are applied before adding them to the query. in this case, the best approach is using parametrized queries, instead of using concatenation when building sql queries.
65337	also, another option is to switch to pdo, which is a bit nicer, as it supports named parameters and more databases. here's a comparison between mysqli and pdo.
65453	if you are not going to change to mysqli or pdo with prepared statements ( which mitigate against sql injection ) then at least ensure you filter any data received from your users - for instance mysql_real_escape_string offers at least some protection.
65503	the action of the form is the address of the current script because you set it to $_server['php_self'].  it's a little tricky, though - it's going to be the script that runs that code, which may or may not be the one loaded directly by the browser.
65602	secondly, by putting $_post values directly in the query like that you are opening yourself up to all sorts of injection attacks. you need to make sure that you are escaping any data properly to prevent that.
65713	to me this has to be updated to type : 'post or get' because php's $_request handles both, so you can change your type to this:
65749	there are a number of problems with the way in which you're attempting to insert the data, but i believe the reason that you're not having any output is because standard mysql commands are deprecated as of php 5.5, and removed as of php 7.0. instead, you should be using mysqli, or preferably, pdo. you'll need to restructure you code to use either, and i recommend reading up a bit on them first.
65750	see http://php.net/manual/en/mysqli.query.php and http://php.net/manual/en/class.pdo.php for further instructions on how to use them. pdo is more secure, but harder to learn, and not all web hosts support it -- make sure to check with your hosting provider!
65751	one thing both methods push heavily is prepared queries. without using a prepared query, you're leaving yourself vulnerable to sql injection. a prepared query binds the parameters being passed through, so they can't be manipulated.
65755	since mysql and its other components are depreciated due to security issues and performance, here is the usage of the mysqli class :
65757	if starting something new from scratch, best use a database wrapper that supports prepared statements like pdo or mysqli.
65910	you must pass a connection whenever you make a query when you're using mysqli. take a look at mysqli_connect()
66059	php sessions are implemented with cookies. whenever you call session_start(), the response includes a set-cookie header which sets a browser cookie containing the php session id. by default (and unless you have renamed the cookie with the session.name php configuration option), the name of the cookie is phpsessid.
66196	isset is a boolean operator which returns true or false. you don't need to compare it to 1.
66197	as a side note, just because the variable is set, does not mean it's not empty. you may want to just check that it's not empty:
66416	from what i can see, your script doesn't handle data from $_post['remark']. you are only handling the $_post['present'] part of your post. remember that each input's name directly corresponds to the post's array index when it is sent.to easier visualize what you are posting and how the data is sent through, you can do:
66428	firstly you have to know about implode() function. mainly the implode() function returns a string from the elements of an array.
66506	first, the mysql api you are using is deprecated and will eventually be removed.  it is recommended you switch to mysqli or pdo for any new development.
66516	you must then bind the paramter to your select statement.  here is why it would be best to switch to mysqli or pdo because the mysql_* functions in php do not support prepared statements and parameterized queries.  read more at how can i prevent sql injection in php?
66569	dont forget to use session_start() in top of your code in login.php and other file if you want to use $_session
66595	make sure you have session_start(); where page starts, additionally you may create unique index on email column in users table.
66731	always use an isset construct to check whether the variable exists.
67011	since most xss attacks rely on &lt; to allow a javascript execution, it is negated cause the &lt; character is not allowed in an email address.
67024	you should not use mysql_ as it is outdated and will be removed in future versions of php.you should switch to mysqli_ or pdo. (overview of the mysql php drivers > choosing an api)
67342	note: mysql api is deprecated as of php 5.5.0. so, it's highly recommended to use mysqli api for newer developments.
67377	using pdo, you should look into prepared statements and binding parameters. it will ensure your values are entered correctly and will do very well at protecting you from sql-injection. the above code is vulnerable to sql injection if $stuff is untrusted input.
67389	for values which are expected to be a number (integer, float) - you can either use intval($var) for integers or floatval($var) for floats.
67391	edit:i forgot to mention: the best is to use pdo(php data objects) -> http://de.php.net/pdo
67394	actually mysql_real_escape_string() is used while sanitize a input from a user. so you should (at least) use it everywhere a user can input anything that goes into a query. it is also very suggested to use prepared statements.
67540	then you should note that even with mysqli::real_escape_string(), it's not secure against sql injection, and that you should use parameterized queries. an example of that is given below.
67543	also note that storing passwords in plain-text is a big no. you should use functions like password_hash() / password_verify() to properly and securely store your users passwords.
67763	an array needs to be printed out using a special function such as print_r. if you want to print out a value in your array try:
67766	when you're debugging, you should use var_dump(). it will tell you the type of the object and its content.
67922	array_push is a built in php function to add an element to the end of an array.  i think you're looking for array_pluck, which is a laravel helper function to pluck a specific key from all the items in an array of arrays or array of objects.
68121	it must be $_request and not $_requests.also beware of sql injection since you are directly using the values.use prepare statemnts to prevent sql injnection.
68626	you have a return; statement that wont run your function fsaveipuserlog() you are also using. also its now encouraged to use mysqli not mysql.
68638	cookies are sent via http header. headers can always be sent. whether they're accepted/ignored is irrelevant - you can send any header you want.
68663	for performance reasons you should probably select only the needed columns in the query. and it is heavily recommended to use pdo or mysqli instead of the mysql_-functions as they are deprecated as of php 5.5.
68746	if just want the key, then you can use array_keys to get an array of keys.
68766	also, mysql_* functions are deprecated. if you want to get hacked, that's cool. if not, maybe look into pdo instead.
69091	prepared statements (via mysqli or pdo) can be useful if you are doing lots of high volume queries that all use the prepared statement. the prepared statements are faster, additionally you don't have to worry about things like escaping data with prepared statements but they take a bit of code overhead so for a simple app sometimes it's not worth using prepared statements and using the old mysql_* functions are easier for the intended purpose.
69338	by default pdo silently ignores errors and returns empty results. this could explain #2. for example, if your table is really called "table" and you didn't quote it with backticks (table is a reserved keyword). turn on error reporting to see if this is the case (see below).
69351	php://input is a read-only stream that allows you to read raw data from the request body. in the case of post requests, it is preferable to use php://input instead of $http_raw_post_data as it does not depend on special php.ini directives.
69461	using $_cookie does not access the client's computer to get the current cookies in real time. during the script, any changes to the cookies are invisible. you won't be able to detect those changes until the next request for the page, when the browser will send the cookies again.
69488	also use pdo and prepared statements to avoid sql injection.
69536	so on your advanced search page, you are looking at doing the following:
69649	also have a look on prepared statements for sql queries, you do not want to have possible injections.
69683	pdo, because it doesn't only support mysql. whereas mysqli, obviously, only supports mysql. if you use pdo you will much more easily make the transition from mysql to, for instance, postgresql.
69855	hint: stop using deprecated mysql_* api. use mysqli_* or pdo with prepared statements. mysql_*will be removed in the next version of php and prepared statements prevent you against sql injection.
69949	secondly, your code looks horrid. you are missing linebreaks, and all. what is more terrifying, that you are totally vulnearable to sql injection. never let the sql execute a command which contains unescaped and unchecked user input. with a little addition to the parameters, you could easily lose your database.
70194	this error means you have outputted something before calling the session_start function.make sure there is nothing above your &lt;?php tag and no outputs before session_start.
70203	the php function array_key_exists will tell you whether $row contains the key you want. for instance, array_key_exists("fr", $row) will return true if $row contains an fr key.
70204	if you want to see all the keys (i.e. all the columns), simply use array_keys; for example : array_keys($row) will give you all the keys in $row.
70465	but there's also the advantage of array_push, you can use it to push multiple elements to an array:
70534	you need to start the session before any usage of it occurrs. so call session_start(); at the beginning of the script.
70535	that query is also unsafe because the value from the session inst escaped. if you use pdo or mysqli you can use a prepared statement to help you with that:
70563	maybe you can compare the session variable with null may be it will be more clear.and don't forget to put your session_start(); before anything else on your page.
71041	read the php documentation on strings. in order to interpolate an array element with a variable index into a string, you have to use the "complex" syntax where you wrap it with curly braces.
71532	first json_decode the json string, so we can work with it in php. then you should use array_unique with the flag sort_regular to remove all duplicates and lastly json_encodeit again to a json string. here's a working example:
71604	having said that, i would strongly suggest that you never allow the user to enter in parts of the actual sql you will run - unless it is a closed/secure environment, which means not an ope website.
71647	please remember that the mysql extension is obsolet, and one should use the new mysqli extension or pdo. you should take a look at those.
71760	finally mysql_* functions are depreciated, and removed from the current version of php - time to move to pdo instead
71956	use mysqli_* or pdo to prevent sql injection attacksadd some parentheses to the query. how can you know that mysql evaluates and and or in the same way as intended?
72065	sessions work very similar to this, except they store the file on the server, which is a more secure, but slightly more complicated process.
72083	when using double quoted strings, you don't need to concatenate variables. compare the above statement with your own.
72085	depending on where the values for $id_member, $b_ref $id_doctor originate, your script could be open to sql injection. rather than inserting values directly into the string, use a prepared statement. mysqli supports them, as does pdo, which is simpler to use. new code should use pdo, and old code should get updated over time.
72109	on a side note, you should not use $_request['name'] but instead use $_post['name'] when the form method is post. it is more secure. and secondly, try to use mysqli database extension instead of using mysql. mysql extension is deprecated from php 5.5 onward.
72358	the wonderful thing about checkboxes is that when you don't have one checked, and you submit a form, nothing is sent to the server. take this checkbox for example:
72547	don't use the mysql_* functions, as they are depreciated. i like pdo, so that's what i'm going to suggest to look into. (just google it, plenty is out there) this will also allow you to use prepared statements, which is one of the biggest things the mysql_* functions are missing.since you're using your post data multiple times, place them into local variables to start. it will make your code short, cleaner, easier to read, and if you ever change the name of a field, must easier to update in the future.place all errors into a single string. that way if it's successful, you only have to check one thing, and if it fails, you only have to send one thing back to the user.
72874	also don't use mysql_ functions. they are deprecated. would advice you to use mysqli since they have protection against sql injection attacks etc.
73120	this part of the code will only execute only if this is set $_session['user'], you need to start the session on the pages that you use sessions with session_start(); before your code.
73178	isset() is a boolean function that tells you if a variable is set or not. if you want to print the value itself, try:
73198	your form will need a method. by default, forms submit data via get parameters in the url, which in php, and in this case, would go to for example $_get['post1']. i'd suggested adding method='post' as an attribute to your &lt;form&gt; as a first step, as all the $_post variables you're referring to currently wouldn't contain anything, if that is an accurate copy/paste of your html form code.
73428	you can also use var_dump passing an array, it'll print the array's structure.
73524	knowing that, and having in mind that in php the value of an assignment expression is the value assigned. that is, the value of "$a = 3" is 3 . a first approach to fix the error might be:
73543	yes, even if cookie is disable.you can call your session whatever scope you are in your program, if you want to unset the session, then you need to use
73547	to destroy all data registered to a session, then use session_destroy in this case the session variable still exists but empty.
73794	i would recommend adding comments to those closing brackets so that you would be able to see which bracket closes which statement. it would look something like:
73896	note i am not getting in the details of the many issues your actual code has: first of all that is open to sql injections as many has already pointed out: take a bit of time to see what prepared statements are. also consider moving to pdo instead of mysqli.
74170	$_server is an array containing information such as headers, paths, and script locations. it defines the path to a file and'document_root'the document root directory under which the current script is executing, as defined in the server's configuration file.detail here afterthat you have added the path to your folder
74171	and at the end include_once is added to eliminate duplication of included file.
74374	if you want it to print as actual html, then you shouldn't use htmlspecialchars(). that function will convert it to character codes that will prevent it from rendering as actual html.
74375	what you want is to print the actual html. htmlspecialchars() will convert any special characters in the string to its associated ascii character code.
74377	of course you could add the trim() like echo trim($error) so there would be no whitespaces on beginning and end.
74506	now, your able to fetch all your data from the array using foreach loop and please use pdo to avoid sql injection.
74517	when you try to store the form submitted values such as post or get, it is really a good habit to check if the value is really sent. you have to use isset to check the same.
74779	and one last note is you are using mysql_query with mysqli_real_escape_string so that i in there has some meaning, or the lack of it in this mysql_query.  the mysql_* functions are deprecated and if i recall removed as of php 7, which means this code is not future proof beyond php 5x.  i am not sure if there is any significant difference between  mysql_real_escape_string and mysqli_real_escape_string
75096	you have to use mb_strtolower for multibyte strings (this applies to many other string functions of php too, see manual).
75187	php uses case-sensitive variable names. you always have to match the exact case.
75200	also consider using pdo instead of mysqli. it's way less circuitous with parameter binding.
75415	to prevent sql injections and make escaping input easy, use prepared statements.
75418	if you don't want html for an input, you can optionally use strip_tags to completely remove the html from the input and then validate it further.
75419	when you want to display a value from the database that came from user input, use htmlspecialchars or htmlentities so that any html tags will be converted from &lt; to &amp;lt; so the output isn't parsed as html therefore allowing people to put malicious links or script tags on your pages.
75438	note :- an useful suggestion is to switch to mysqli_* or pdo is best, because mysql_* is officially deprecated.
75445	to be able to see database errors, one have to set pdo errmode to exceptions. exceptions are better than regular errors in many ways: they always contains a stack trace, they can be caught using try..catch or handled using dedicated error handler. and even unhandled, they act as regular php errors providing all the important information, following site-wide error reporting settings.
75751	if you want to execute several sql statements in a single query, you need to use mysqli and multi-query, and each statement needs to be separated by a semi-colon (;)
75758	you should also either use prepared statements or at the very least sanitise your inputs, as your code has a huge sql injection vulnerability (how are people still writing php like this?!? what are they teaching in these "schools"?! aghh!)
75767	on the other hand, your code is extremely prone to sql injection attacks, always clean your $_post and $_get input before using it in the query directly!
75992	yes, shared state is usually stored in a database, although state may also be stored in the local file system.
76045	$_cookie is read only array, you need to use setcookie like
76124	it is because you are accessing the $_post array without checking that the key exists. you must check that the key exists before accessing it:
76279	you're better off using pdo or mysqli prepared statementsyou should always read the manual - password_verify(), it states clearly that you compare the "user inputted password" against the hashed version which is stored in your database.
76304	unchecked checkboxes don't get submitted to the server. so $_post['monday'] is just an array of all the checked boxes. the indexes of these parameters won't match up with the text boxes.
76452	if you want replace a know, exact substring, you have to use str_replace instead.
76499	you should stop using mysql_* functions. these extensions have been removed in php 7. learn about prepared statements for pdo and mysqli and consider using pdo, it's really pretty easy.
76659	to create an an array, you need to declare it using array() feature. below i have created a blank array.
76947	edit : please make sure to use pdo or mysqli instead of the deprecated mysql module, as it may not be as secure as the newer soultions and will finally get removed from php. both pdo and mysqli support new database mechanisms like prepared statements, while (at least mysqli) still providing similiar functions.
77107	if $phone = null (like if the value wasn't posted), $phone == '' evaluates as true. because '' is loosely equivalent to null.  you either nee to use a strict comparison ===, or better yet use empty().  i personally handle all such stuff up front when initializing the variable (including sanitizing the input value, as there is no sense in passing unsafe data further into your application.  here is what i might suggest:
77108	also you should really look into replacing the deprecated mysql_* functions in your code with mysqli or pdo equivalents.  note you also need to change your code to populate $mistake, as with a returned value of 'not specified' for $phone, you would not trigger that conditional.
77198	also, as @damienlegros noted in his answer, you should always have the session_start() statement as early as possible in your code, i.e. as one of the first statements, so you make sure no output has been made before it's started. otherwise you'll start getting errors stating that headers has already been sent.
77276	if you are just looking to get results out of a select query, you can use output parameter binding, the basis of which is bind_result. this does not appear to need the additional extension.
77279	also, if you're on php5 you should use a pdo object instead, for connecting to the database, and you shouldn't put vars directly into mysql queries (that allows sql parser to be injected with sql code from the user). you need to use parametrized queries.how can i prevent sql injection in php?
77280	additionally, do prevent from sql injection, you should also sanitize your inputs ($_post data) before saving them.
77389	strchr() will give you true/false if the character (in your case, ".") exists in the string. so to get the file extension, you could use something like:
77797	in the php pages you need to access session variable add session_start() after the starting &lt;?php code
77999	and use pdo or mysqli as suggested in the comments.
78046	note: the above example uses pdo, which you should really look at using, since the mysql_ functions are deprecated. see this question: why shouldn&#39;t i use mysql_* functions in php?
78117	you cannot check variable is empty by isset();. you have to use is_empty(); method to find it.
78446	keep in mind that everything in php is case sensitive. you use the querystring session, but in code you can't refer to session, you must use session.
78516	an array when cast to a string will simply be output as the string "array". if you want to output each element in the array, loop through them or use something like join:
79039	use mysqli_real_escape_string when inputting strings into a database. it won't do what you expect when outputting to screen - so anything that has been mysql escaped() should not appear on screen.use htmlspecialchars (which you don't have!) when outputting to screen.use url_encode for adding stuff into a urlthere are also many different "escape" function (e.g. inserting into json, inserting into mysql, inserting into other databases). use the right one for what you need - and don't use it for other purposes.
79233	cookies should be set before browser output as they are part of the http header.
79354	it is a bloated formatting for var_dump. print_r() in pre tags is faster and more lightweight but this is amazing for debugging as it shows data types and also shows empty() variables.
79441	i would also sugeest you to stop using  mysql_ api since they are depecrated, please switch to pdo or mysqli
79625	incidentally - the api.php code is vulnerable to sql injection so you ought to be using prepared statements
79661	also, yes, you are at risk for sql injection. first step to fixing this: don't use mysql. instead use mysqli or pdo and utilize prepared statements.
79806	isset is only necessary if you're trying to work with variables that may not exist. in your case you're calling a function, which certainly exists. hence you don't need and in fact can't use isset here. just use if ($this-&gt;session-&gt;flashdata('login_error')) if you want to test whether the value is truthy.
79808	isset only checks if a variable in instantiated. since you can only return instantiated variables, isset is invalid there. your best bet would be to do it like:
79859	you use fetchall in you pdo statement, which will return an array. so you need to access by $row[0]['name'], or use
80120	also, you're prone to sql injection with that query. you should use something like pdo to bind parameters to your sql query.
80130	you have to treat all and any user input accordingly to prevent that, using prepared statements, or some escape function such as mysql_real_escape_string() / mysqli_real_escape_string() etc. look for the options available to whatever database connection method you are user.
80294	the function prepare() returns an object of pdostatement class. as it says on the php manual, pdostatement::execute() does not return results, it returns a boolean instead to indicate if the query was successful or not. you need to use the fetch commands the pdostatement has.
80354	as you see, i have put your $cart variable into the $_session. thus you do not need to retrieve it again from the database when the user navigates on your site. this will  reduce load on the database as well as speed up your script. for a shopping website it is really important that the website will load as fast as possible, so that the customers enjoy shopping and staying on the site.
80364	you should always sanitize input. a good starting point is filter_var(). using the right flags for validation and sanitization and makes your input save(r). keep in mind that filter_validate_* only tells you if something is valid, while filter_sanitize_* actually cleans your data from unwanted and potentially malicious data.
80603	you also should move away from mysql_ as the mysql api is deprecated.  use pdo or mysqli with prepared statements to avoid sql injections.  right now, your query is open to injections using a $_post variable directly in the query.
80604	for debugging purposes, i suggest you print out the array if you're having trouble in the future using: print_r($auser).  it may have saved you a trip here.
80634	i will also add that you need to check the sql-injection and escape your fields or, better, use pdo and prepared statements.
80637	first of all, please use pdo or mysqli.. mysql extension is depreciated.
80758	as markus intimated, your code is extremely vulnerable to sql injection attacks.  further, the php manual strongly recommends using the mysqli extension, over the mysql extension.
80877	but even better is to use prepared statements with query parameters instead of escaping and concatenating variables into sql query strings.
80927	use mysqli_* or pdo, because mysql_* is deprecated and closed in php 7.your code is open for sql injection, you must need to protect with sql injection or just simply use prepared statement.
81044	you approach is wrong, you need to have session_start() at the very top of the page, than use a session variable like this
81073	this can be done with a single line of code using the array_diff function which returns all items in the first array that are not present in the second array.
81185	you should use $_post['image_encoded']. the $_post identifier is actually an array, so the brackets should be square brackets. to test this yourself you could output print_r($_post); once, as you'll never forget it again then.
81333	it is a good idea to have an object encapsulating the access to global variables such as $_server, $_get, $_post or $_session as in your example. it is common practice in mvc architecture to do so.
81811	you need to specify your method type so in your php code you can get it using that method. if you leave out the method part it by default uses $_get. seeing as your code is pointing to $_post then you set it to method="post".
81812	you also need to set action="" this can be set to # for same page or leave it blank or using a file name. this will redirect the form to that page.
81938	add error reporting to the top of your file(s) which will help find errors.
81941	use mysqli with prepared statements, or pdo with prepared statements.
82172	if a variable has been unset with unset(), it will no longer be set. isset() will return false if testing a variable that has been set to null. also note that a null character ("\0") is not equivalent to the php null constant.
82266	they behave differently because in sort the $myarray variable is passed by reference, meaning the variable itself is operated on whereas in array_reverse() the variable is not passed by reference. you could simulate this behavior by using array_reverse(&amp;$myarray) although, please note that as of php 5.3.0 call-time pass by reference was deprecated and it was completely removed in php 5.4.0
82586	but if you have a query that's basically the same and only uses different values in the where clause, you will get faster query executions by using prepared statements.
82587	note that it's bad practise to interpolate variables into queries due the risk of sql injection attacks. but since we make sure the ids are numeric, it's okay in this case. also, mysqli does not allow easy binding of values in where … in queries.
82698	only checked checkboxes are sent to the server. so, if the value is not present in the array, that's because the box wasn't checked.
82790	better yet, learn pdo instead, as, unlike mysqli, it's already a ready to use database access class, with it you don't need functions like processrowset, for example.
83179	local variables that are defined and used in a function are not automatically unset after the function is executed.  rather they are marked for collection by the garbage collector.  unless you are consuming large amounts of memory with the definition of a local variable there really isn't a need to explicitly unset them.  just let the garbage collector do its job.
83201	it's important to note that there are several layers to consider when making a database connection. first you need to connect to the server, then you connect to your database of choice. once that's done then you can run your query.
83390	at the top of each page, you run session_start() before anything else. this will load any existing session, or start a new one if none exists.
83555	both htmlspecialchars and htmlentities are subceptible to the infamous utf-7 problem. none of them support this encoding. as you can read in some of the comments of the so posts provided at the bottom of the post:
83557	htmlspecialchars will default to utf-8 (in php 5.4/5.5) if you don't specify the third parameter so you should be safe even if you forgot to establish it.
83626	please don't use mysql_* it is deprecated and removed from php 7.
84136	if you want to extract some data from a string that contains something that looks like a query string, you'll want to take a look at parse_str().
84459	like other user have said, don't forget to add session_start() somewhere in the beginning of your code.
84485	the mysql extension is deprecated since php 5.5.0 and mysqli (note the i at the end) or php pdo should be used instead. also, you are probably getting the division by zero warning because $count or $limit is returning 0.
84674	the value of $domain was never declared. if you would like to get form data you need to use the $_get, $_post, or $_request object(s), in your case you are using the post method in your form so instead of $domain use $_post["domain"]:
85330	i suggest you should use stripos, not strpos for your purposes, as it is case-insensitive and will also find words with uppercase letters, if it's something you might need.
85425	one final note, i notice you're using a fixed salt value. wouldn't it be better to generate this value randomly each time you need it and then store it in the users table? generally, a salt is not intended to be secret, it's just there to prevent people precomputing tables of passwords using the hash algorithm that you use.
85466	and also, as a side note: i highly recommend switching to mysqli from mysql, which is deprecated.
85535	like other people already mentioned, please do not use mysql_* since it exposes you to sql-injection (use mysqli or pdo instead).
85748	note you are vulnerable to sql injection.  since you are using mysqli, you may wish to consider using mysqli prepared statements.
85781	in the code you posted, mysql_real_escape_string is used to encode(=escape) user inputs. the code is therefore correct, i.e. does not allow any sql injection attacks.
85837	you can use php's $_get array to access url parameters.
85888	you can use strpos to search for an occurrence of a string within a string.and use an array for the search argument for str_replace.  which will simplify your code.
86038	here is the link for the escape string, but you may want to consider the best alternative, and that is to paramterize the inserts
86077	you should also look at the pdo driver (php data objects), which provides a data access abstraction layer allowing your code to access many more dbms besides and including mysql.
86260	note that the above doesn't check for bogus input (always a good idea to validate input server-side as well as client-side). aside from that, mysql_* functions are deprecated, move to mysqli_* if possible.
86280	is_float() checks the type, not the content of the variable where is_numeric() only checks the value. however, you can try to convert the value by doing the following:
86283	and mysql_ functions has been deprecated since 5.5.0, you should port your code to pdo or mysqli , you'll find an excellent guide here http://wiki.hashphp.org/pdo_tutorial_for_mysql_developers
86384	if you want to interpolate a variable into a string, you have to use double quotes, not single quotes. see what is the difference between single-quoted and double-quoted strings in php?
86739	note,(1) you are open to sql injection by using $_get values directly in your query, and(2) from the mysql_ doc - this extension is deprecated as of php 5.5.0, and will be removed in the future. instead, the mysqli or pdo_mysql extension should be used. see also mysql: choosing an api guide and related faq for more information.
86807	with isset() you check if the certain $_post parameters are set, but not validated. you should at least do a basic validation of the data to see if they are correct!
87054	your code is prone to sql injection. use pdo or mysqli
87304	__file__ is part of the magic constants and will return the absolute path of the current included file.
87305	$_server['script_name'] is a part of the predefined server variables, and will return the path of the script originally called in the server relative to the server root path.
87307	you might want to use __file__ when logging messages or when looking to extract the current project name, branch name, etc.. and you might want to use $_server['script_name'] when you are looking to refresh the page, identify the origin of the call, and so on.
87308	in your example you are using basename(__file__) which will in that case return the name of the included file.
87312	instead of doing the session_start in each page, make a common.php file and include this file in all the required pages. also, you need to make sure there is no white space before session is started, otherwise it would throw the header already sent error!
87642	in a web application, the only way to share information between users is to store that info, on the server! in your case you decided to go for a mysql a database. that is the most common choice that goes along with php!
87643	notice: the new standard interface to access a mysql database isn't through mysql_* functions anymore! this extension is deprecated already and will be removed within the next versions of php! its preferible to go with mysqli_* functions instead or to use one of the two object oriented alternatives available mysqli and pdo
87926	the correct way to access post values is to use the predefined variable $_post (all capitals). i would also consider using the htmlentities function to sanitise the incoming data before you display it on your web page.
87988	implode() does the exact opposite of explode().  basically, it glues the entire array back together with whatever string you want (a &lt;br&gt; in this case).  so the only code you would need to display the postcodes in order would be:
88016	note: you need to start session at top of file users.php as well.
88220	any approach that uses $_post values directly in sql is vulnerable to sql injection, though.
88442	note :- mysql_* has been deprecated use mysqli_* or pdo
88454	also you should format all strings with mysql_real_escape_string() as this prevents hackers being able to attack your database by passing sql in the string. for integers and floats you should use intval() and floatval() for the same reason.
88456	try using mysqli instead of mysql (depreciated) in php, you can also use pdo, however pdo is not as comprehensive and upto date as mysqli, and due to this is slightly slower.  the only advantage of pdo over mysqli is that pdo also works with postgesql, so switching database engine is easier, however the sql between mysql and postresql differ slightly, so it's not that easy.
88467	unfortunately, array_walk_recursive is designed so, that it can't edit keys. if you need edit keys, you may want to write your own recursive function. i don't want to copy answer, you can find it here
88825	1) stop using mysql_ functions and use only mysqli_ functions (or pdo) . mysql_ php funtions are deprecated and no longer supported (and hasn't been for 5+ years!). it is insecure and will only get worse.
88830	it is normally good practice to do all your database connectivity at the top of the page, then display the results.
88833	bad note - your code is wide open to injection attacks. you are using form data with no verification. that's a big red flag. secondly, you are using deprecated mysql_* functions. your code should be using mysqli_* functions or better yet move to pdo. it is much safer and you will be able to do a lot more with it.
88912	array_search() returns you the key already, or false if value is not found. using in_array you won't directly get the key, if that's your aim. you could check if the return value is false|null at the place you call this function. i would do return $key ?? null(php 7+)
89105	you're using exit in your switch, which (unless you want your script to end at the switch) is a no-no. instead, you have to use the break keyword.
89111	you could get the complete get variable with $_get then you have an array that you can browse with
89321	also note that the mysql extension is deprecated (and probably unmaintained). you should be using mysqli or pdo.
89338	php's isset checks to see if the referenced variable has a value assigned - if it does, echo it.
89383	you did protect from mysql injection, but the string you stored is way off from its original format.functions such as strip_tags, htmlspecialchars and trim should be used when you are pulling the string out and echoing it.
89388	i think you should store the username and password as it is and do htmlspecialchars only when  displaying them.
89445	you need to learn about sql injections and also about securing your passwords, use mysqli prepared statements / pdo what ever you find easy to learn
89651	also you told that you are new to php, so consider using pdo instead of mysqli_(), than you don't have to worry much about sanitizing your user inputs...
90015	pdostatement::execute() only returns a boolean indicating success or failure, so your variable $num is not what you want to fetch from.  by assigning the result to $num, you are not assigning the object $prep, but rather only the return value of the method call to execute() (true).
90122	but remember: cookies are saved local on the client pc. so the user can watch the cookie values. it would be the best you encrypt the cookie data so the user can't see the values in plain text.
90462	also, as a suggestion, you only need to prepare() a query once.  you can re-use it.
90550	you should also be using something other than mysql_* to interact with your database, for example pdo:
90845	add error reporting to the top of your file(s) which will help find errors.
90989	sidenote: you theoretically could with older versions of php, but as of php 7.0, the mysql_ api has been removed, so you definitely wouldn't be able to use it here if that were the case.
90990	what you need to use here is a pdo prepared statement in order to escape the data, which is what you are looking to do here.
90999	add error reporting to the top of your file(s) which will help find errors.
91071	if you try to find a string from another string, you can strpos().
91193	you always want to escape ` identifiers, even table names and field names, as maybe tomorrow they will be reserved words and break your query. as long as you are using prepared statements (pdo, mysqli, or whatever) you will be fine. note that pdo won't allow to escape table or field names.
91251	better yet would be to use named placeholders and pdo.
91252	using pdo means you don't have to worry about things such as sql injection, and it allows for far cleaner sql statements, you don't have to be throwing values from php directly into the sql.
91301	also if you are writing this as new code consider converting your mysql_ functions to mysqli_ or use pdo as mysl is now deprecated and no longer supported in php.
91446	i would also like to point out the use of prepared statements here, as they are the only way to properly defend against sql injections.
91536	if possible you should move away from mysql_*** function in favor of mysqli or pdo. in addition to using prepared statements to protect queries from injection.http://php.net/manual/en/pdo.prepared-statements.phphttp://php.net/manual/en/mysqli.prepare.php
91689	notephp mysql_* functions have been depricated since version 5.5.* and are going to be removed from the language soon. you should look into mysqli_* or pdo.
91893	also: please please please sanitize $_post["subject"] before using it in a database query. a user could easily add a fake option to the select locally with a malicious string for value, and you'd unknowingly query the db with that. you can use prepared statements for this (mysqli has the prepare() function to prepare a statement before querying). more on that and combating sql injection here.
92203	also, your current queries are ripe for sql injection, and myslq_ functions should not be used for new development. change to mysqli or pdo and make sure your safely escaped!
92774	what you're looking for are $_session variables, which stay active until the user closes the browser or until the session expires (i think the default php config time is 24 minutes..?). this is a lot more efficient than storing them in a database for temporal purposes.
92776	to utilize session variables you will need &lt;?php session_start(); ?&gt; at the beginning of your pages (before any html is used)
92902	finally, i wouldn't be doing my duty as a so answerer if i didn't point out that the mysql_xxx functions are deprecated and should not be used in any new code. they have been superceded by mysqli_xxx and pdo. these allow you to create "prepared" statements, so you don't have to substitute variables into strings as above, which potentially allows sql-injection attacks unless you're careful to sanitize your data (i didn't do so above for expediency).
93265	you don't need to use session_start(); twice as that may trigger that the session was already started.
93268	add error reporting to the top of your file(s) which will help find errors.
93574	if you want to get all matches string, use preg_match_all() that find all matches.
93667	ensure that the variable is an array before looping with is_array:
93700	to check whether a property exists in an object you can use property_exists():
93710	note :- mysql_* has been deprecated use mysqli_* or pdo
93791	isset returns true or false if a variable is set, it does not return actual variable data.
93810	as a side note, the error message "wrong password" is misleading.  first of all, it could have been the username which was wrong as well.  second of all, never provide an unauthorized user with more information than they already have.  if you tell an attacker that they got a username right and just got the password wrong, you've given them have of the login information.  if anything doesn't match in the login, simply say that the login has failed.
94338	obligatory suggestion, don't use mysql_* functions in new code. they are no longer maintained and are officially deprecated. see the red box? learn about prepared statements instead, and use pdo or mysqli - this article will help you decide which. if you choose pdo, here is a good tutorial.
94418	as pointed out in the comments, you really should start using mysqli instead of mysql.
94502	also, don't change to mysql, it is far too old now! look at mysqli and the php data object both are very well documented
94552	you really should sanititze your user-input before using it in a query, otherwise your site is vulnarable to sql-injection.
94731	mysql is depreciated, you should use mysqli or pdo. one thing i noticed is on $_session['username']==$dbusername; shouldn't it be only 1 equals? as your assigning $dbusername to the $_session['username'] variable.
95150	never trust user input!  at a minimum, wrap the $_get['name'] in a sanitizing function, like mysql_real_escape_string() to prevent sql injection attacks.  and then when you're outputting user-supplied data, make sure to wrap it in htmlspecialchars() to prevent cross-site scripting (xss) attacks.
95153	i've always stood by the idea that data should go into the database as raw as possible.
95178	however, you really should move from mysql_* to pdo or mysqli.
95194	i suggest to work with pdo, instead of mysql_... functions.not only because it's newer and object oriented but also because mysql... is deprecated.so my answer is with pdo
95412	p.s. please don't use mysql_* functions, use mysqli or pdo instead.
95463	key() method would give the key of the current element of the array, so the argument for this method should be an array.
95464	if you are looking for all the keys of an array you can use array_keys.refer this for more details: http://php.net/manual/en/function.array-keys.php
95507	by building sql statements with outside variables, you are leaving yourself wide open to sql injection attacks.
95578	however it is bad practice to use global variables in functions, just make sure you never overwrite the $dbcon variable, it might happen when using code from somebody else.
95698	use mysqli or pdo instead. mysql is deprecated and can lead you to a whole lot of trouble. think about sql inyection.
95978	don't bother though... your code is incredibly insecure and wide open to sql injection attacks.  use prepared/parameterized queries with pdo or similar, or you will be hacked without doubt.  also, don't use encryption on these passwords... uses hashes with salts, which are one-way functions.
96214	if you want to include the form name, use a hidden field like this inside the form:
96456	the $_session variable is always set - regardless if you have initialized the session or not. you must actually assing something in $_session array to get results. for example after succesful login do this:
96846	that being said, keep in mind that cookies are not safe, i.e., although most users won't see them, they are in no way secure against reading and/or writing them by user. if you need secure variables that are inaccessible by user, consider using sessions - session_start() and $_session.
96897	edit: by the way, you always need to prepare your data for use in a database. i prefer prepared statements / pdo but if you use regular mysql you need to escape your variables before you insert them using something like mysql_real_escape_string.
97027	mysql_*() functions are deprecated. don't use them. use mysqli_*() or pdo instead.you're using trim(strip_tags()) as some form of sanitization. this is nowhere near good enough. you should use mysql_real_escape_string() (for mysql), or consider moving to prepared statements.
97053	also, mysql_* extensions are discouraged. move to mysqli or pdo_mysql, for new projects.
97151	because $_post is a global variable of php, it exists in every php thread, so isset($_post) will return true, in your example the value of $_post is an empty array. you can have a try like blow:
97193	well the problem is $_session value can be set and used on server side only.if you want this content on client side javascript you will have to send a request to php server for datacache value and then set it in your local storage.you may use ajax call like
97507	if you would like to learn how to use a real object oriented database layer, use doctrine. with 3 pages tutorial, you can do the most general things. however some very special cases are better coded in raw sql than with doctrine. but if you know how to do things with doctrine it is a very useful library and you end up writing better, consistenter, more readabler and extensiabler (:-)) code.
97772	make sure you're calling session_start(), always and only once (ie. it should be in one place in your whole application).make sure you're setting the session value before you check it.abstract away anything to do with sessions. don't check the session variables yourself, write a class that does it for you. like: $user-&gt;setgalleryadmin(true) and $user-&gt;isgalleryadmin()
97835	as has already been suggested, try using "date_default_timezone_set" and "date" to get the date in your local timezone.
97836	use mysqli instead of mysql functions as mysql functions are deprecatedescape your strings! to avoid sql injection use mysqli_real_escape_string on anything that comes from the request
97860	strip_tags is useless, because it is only relevant in an html context. any one of the other two methods would be sufficient to prevent sql injection. generally, just use the appropriate escaping mechanism for the language you're dealing with. in this case you're dealing with sql, so mysql_real_escape_string alone is fine. see the great escapism (or: what you need to know to work with text within text) for a step-by-step approach to escaping.
97861	better yet, learn pdo with prepared statements instead of the deprecated mysql_ functions, which solves the issue of sql injection much better.
98257	you have to start a session with session_start() before checking th session, and to make sure that the session has been opened with the correct name and value.
98423	since you're utilizing mysqli use prepared statements instead of interpolating query strings, which leaves your code wide open to sql injections.
98461	be careful with potential sql injection. use at least mysql_real_escape_string() on user input, or better bind your variables to your queries.use of old mysql_* php functions is discouraged. use of pdo library is preferred. check orms like propel or doctine as well.you can add limit 1 to your query to avoid useless processing, if your goal is to check only if at least one match is found in table crm given the party_id.
98689	anyway, the mysql functions, you use, are deprecated. have a look at pdo or mysqli as a replacement!
98994	session_destroy will delete your complete session. if you want to delete particular session value use unset function, somewhat like this
99027	by the way please, don't use mysql_* functions in new code. they are no longer maintained and are officially deprecated. see the red box? learn about prepared statements instead, and use pdo or mysqli - this article will help you decide which. if you choose pdo, here is a good tutorial.
99472	you should look at moving to mysqli_* or pdo - mysql_* is being deprecated. you can do multiple queries in one call directly using mysqli, too; and they both make use of bound parameters, which helps you write more secure code.
99620	as a side note, mysql_query is deprecated, you should look into mysqli and prepared statements.
99762	you have to start the session using session_start(). this call will restore the $_session array to what it was after the previous request.
99763	$cookiesession is a php resource. php resources are freed after the php script is executed, so it makes no sense to store them in a session. i suspect you want $cookiesession to be the record in the databases. use mysql_fetch_array($cookiesession) to retrieve the database record. but note that the mysql extension is deprecated and should therefore not be used in new code. use pdo or mysqli instead.
99934	if you want to fetch data you have to use select statement not insert statement. please check this answer hope it will helps you.
100036	try using print_r or die to debug the value of the variables.
100046	also, if working with $_session variables, make sure to have session_start() on top of each page where you need to access $_session variables.
101151	and consider using mysqli or pdo (and use parameterized queries), as mysql_* are deprecated!
102036	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;you can check this post for sql injection prevention : how to prevent sql injection in php? . and you can check this other post for reasons why mysql_* methods were deprecated: why shouldn't i use mysql_* functions in php?
102058	so i'm going to go ahead and suggest you make a major change to your code: don't use mysql_* functions as they are deprecated.
102167	first thing first to make sure that empty values are not inserted, you need to check if that value is set from the form then execute the query when the value is set, also you need to prepare your statements when using pdo, also don't directly enter you variables in your query use placeholders instead.
102180	first of all, use pdo or mysqli functions for database queries.
102293	as mentioned refrain from using mysql_ functions which as of php 7 (current version) this extension is no longer available. use either mysqli or pdo.
102429	on windows, the php_eol will default to \r\n, while on linux it would be \n only. therefore, if the file was created on windows and you run your code on linux, it could try to find linux's end-of-line and fail to explode the file correctly and vice-versa.
102823	additional info if required:-make sure you use session_start() at top of your page if not you may face with an headers already sent error / warning which again can be fixed by output buffering ob_start()
102954	don't use any mysql_* functions. they're deprecated. use mysqli or pdo instead.
103145	on a side note: your code is vulnerable to sql-injections. switch to mysqli or pdo and use prepared statements.
103212	firstly, if that is code to be used in production, please make sure you are escaping your sql parameters before plugging them in to your statement. nobody enjoys a sql injection attack. i would recommend using pdo instead as it supports prepared statements and parameter binding which is much much safer.
103231	on a side note, in fact the general rules of thumb is that, you shouldn't alter user input at all. you should store whatever user input as it is, into your database, so that you can retain user input as original as possible, and only escape it when you need to display or use it.
103649	first of all, don't check with isset. since $_post is always generated you should be using !empty().
103879	another good habit is to check for errors after every call to pdo::prepare() or pdostatement::execute().  either enable exception mode, or else check the return values for false:
104105	that's because when you hit the 2nd, 3rd, ... page(after navigating from the 1st page), the $_post array would be empty i.e. $_post['search'] won't be set. since you're not sending any sensitive data with the form, use get instead of post in the method attribute of the form, like this:
104107	sidenote: learn about prepared statement because right now your queries are susceptible to sql injection attack. also see how you can prevent sql injection in php.
104356	there are multiple advantages when using pdo. first you do not need to escape your parameters or your full sql query because, with pdo, you will be using prepared statements.
104769	keep in mind that str_replace returns a string. it don't change the string you passed to it.
104808	mysql_query is deprecated, please consider either mysqli or pdo.this approach is vulnerable to sql injection attacks. consider using a prepared statement.
104950	in_array — checks if a value exists in an array
105044	but really you should use pdo instead of the deprecated mysql_* functions...google pdo, and learn to do prepared statements.
105069	use prepared statements in order to avoid mysql injection.use exception handling in order to catch all errors and handle them correspondingly. especially when you run database operations.use pdo instead of mysqli.
105179	don't use mysql_*() for new code - it's depracated. switch to mysqli_*() or pdo now.your code is susceptible to sql injection. escape your input variables with mysql_real_escape_string() (or the mysqli equivalent) or better, switch to prepared statements.
105658	if your other script happens to be using this word as a column reference, you will need to set it inside backticks, since key is a mysql reserved word. i'm just thinking outloud here.
105659	add error reporting to the top of your file(s) which will help during production testing.
105660	plus, i recommend you use mysqli_ functions with prepared statements, or pdo with prepared statements.
106188	also, please note using pdo or mysqli for your requests. mysql is deprecated and can be vulnerable about sql injections.if you want to still on mysql and to don't use mysqli or pdo, you can use this mysql function to escape strings from the user to prevent sql injection:
106281	sidenote: don't use mysql_* functions, they are deprecated as of php 5.5 and are removed altogether in php 7.0. use mysqli or pdo instead. and this is why you shouldn't use mysql_* functions.
106329	please update your code to use pdo. inserting into the database could be much easier and safer using prepared statements.
106731	first of all, you need to escape your values before insterting them in a query, especially if they come from the user ($_post, etc.). mysql_real_escape_string() does that for you.
106733	really you should be using parameter placeholders (?) for the values and prepare the statement with pdo or equivalent.
106859	also use mysqli instead of mysql to avoid sql injection.
107059	always start session page with session_start().if you want to use session first assign session a value like this :
107070	but you have to initialize session_start(); in all web pages where you have need to access that session variables.
107090	strpos will return 0 if the needle is at the very start of the haystack. but 0 evaluates to boolean false, so your if condition fails.
107128	usually lines are seperated by \r\n [windows] \n [linux] or \r [mac] so you could use it.if the lines arent formatted with those line breaks you could easily explode it using regular expressions -
108041	you should use mysqli_connect instead of mysql_connect which is deprecated since php 5.5.0 :
108369	one of the advantages of pdo is that it allows parameter binding, which protects you from sql injection.  so instead of:
108647	i highly recommend looking into using a pdo connection because it will be much more portable and parameterized queries pretty much eliminate security issues if used properly.
108648	all mysql_* functions are going to be deprecated as well so you should invest your time in learning the newest standards. a mechanic is not going to focus on learning carborated engines, they are going to focus on fuel-injection systems.
109139	or better yet, use prepared statements with mysqli or pdo.
109199	as i stated in comments, you need to start the session first and placed on top before anything is happening or meant to happen.
109429	you can use array_values (to get the values and ignore the keys).
109915	you have to use array_search() instead of in_array() to get the key of the found element.
110016	fixed it. all i needed to do was add make sure the session_start() was at the start of each page that used it before the output, other wise it wouldn't work.
110449	it is very important to use mysqli_* functions not mysql_* ones (they are deprecated) or even better pdo. at least sanitize and validate your inputs so your data will be as valid as you can.
110805	when you set a php variable, it will disappear as soon as the php script finishes. however, if you use php $_session variable, it will persist.
110806	to use the php $_session variables, just add session_start() at very top of all php scripts. note that session_start() must be the first instruction -- if any other php headers are sent, session_start() will not work.
110808	therefore, have your other php file also test the $_session['submitted'] variable (again, session_start() is required up top) to ensure it is okay to run the db insert.
111280	sidenote: don't use mysql_* functions, they are deprecated as of php 5.5 and are removed altogether in php 7.0. use mysqli or pdo instead. and this is why you shouldn't use mysql_* functions.
111344	you can check email field is not empty and then you can use filter_var to validate provided email.
111665	in your sql query string you are not providing the adminid variable, instead you are fetching a user who has the adminid equal to the string value "$adminid", the right way to put variables in a sql query using pdo is by using prepare with tokens referring to the variables, then giving an array that associates each token to a php variable, like this :
111920	in addition, your code is highly insecure. at least use mysql_real_escape_string(), e.g. $name=mysql_real_escape_string($_request['req-name']); to protect against sql injection.
112005	you need to call session_start() whenever you are using session. you don't need to check session_id().
112077	another option is to use __dir__ or dirname(__file__) depending on the php version you are using. either of those two ways will return the folder name where the file that is executed by php resides in.
112096	make sure magic quotes are off or, if you can't disable them, cleanse your strings from them. read the manual for details: http://www.php.net/manual/en/security.magicquotes.phpwhen inserting your text into the database, escape it properly for sql syntax once or, better, use prepared statements. see how can i prevent sql injection in php? and the great escapism (or: what you need to know to work with text within text).when outputting to html, use htmlspecialchars to avoid html injection or plain syntax problems and afterwards use nl2br to format line breaks specifically for html.
112176	first of all: never use unescaped $_get, $_post, $_request, $_session. further reading: http://phpsecurity.readthedocs.org/en/latest/cross-site-scripting-%28xss%29.html
112311	newer version of php has deprecated mysql functions. use mysqli or pdo instead. if you are using older version try installing ph5-mysql first.
112618	in order to appropriately pass null value from php to mysql using pdo see this so topic
112664	isset checks the variable to see if it has been set, in other words, it checks to see if the variable is any value except null or not assigned a value. isset returns true if the variable exists and has a value other than null. that means variables assigned a " ", 0, "0", or false are set, and therefore are true for isset.
112665	empty checks to see if a variable is empty. empty is interpreted as: " " (an empty string), 0 (0 as an integer), 0.0 (0 as a float), "0" (0 as a string), null, false, array() (an empty array), and "$var;" (a variable declared, but without a value in a class.
112677	to check is key exists in array better use array_key_exists because if you have null values isset returns false
112715	moreover, you shouldn't use mysql_* functions because are deprecated. use pdo or mysqli_* instead
112904	you have to call session_start() at the top of each of your script in order to actually create a session
113075	using prepared statements removes the need to sanitize user input, as harmful input is not substituted into the query directly. for more reading:
113076	there are some good tips for using prepared statements in many different scenarios, as well as towards the bottom, there is an explanation on how prepared statements prevent sql injection.
114273	if you want to send data via the url you have to use a get request. to do this, change the type of the request to get and give the object directly to the data parameter in your jquery, and use $_get instead of $_post in your php.
115121	you should use mysqli and not mysql as it is deprecatedsecondly, you should check if($results-&gt;num_rows === 0) and do your insert
115191	as we discussed in the comments, your code snippet shows that you are using both mysql and mysqli functions. you should pick one and stick with it. mysqli is the strongly preferred choice as mysql is deprecated.
115421	please always prepare your query, never use a $_post or any other user input value directly in your query to prevent sql injection.
115449	first of all, you really should use mysqli. standard mysql_ functions are now deprecated, and for very solid reasons. your code would look something like this, if it was rewritten using mysqli:
115816	your code would not be considered insecure but you really shoud ditch the mysql_* library in favor of pdo or mysqli and use prepared statements where user input is needed in the query.
115984	next, use prepared statements - it's a security thing (read about sql injection). never, ever put external variables into query like this:
116002	use the mysqli or the pdo extension instead of the old mysql extension.
116399	by the way, consider using pdo or mysqli for manipulating database. mysql_ functions are deprecated :
116423	whenever you concatenate in a sql query you should be using a prepared statement instead, as it opens you application to sql injection attacks. now that i look closer you are using escape_string while this is good, the preferred way is prepared statements. this is because with a prepared statement, the variables are entirely separate from the query commands and so the db knows not to execute anything in them.  even with escaping there could be edge cases that may be an issue, i don't know of any per-say, but something like using a hexadecimal version of a quote are things i have seen in examples, or weird character strings that the db would see as a quote.
116674	before accessing $_session you first need to initialise session using session_start(); on the top of the page
116679	please note that sessions will not work if you use php from the command line
116759	another alternative, if you don't want to loop through all those arrays, is to use the print_r function with its second optional parameter set to true.  this will transform the array into a user-readable string.
116977	second, you should not be using mysql unless you are using an outdated version of php.  switch to mysqli or pdo.
116983	as others have already stated, you should be using the mysqli function set as opposed to the mysql function set.
117111	output plain html if you are sure about the contents. use htmlspecialchars on every other resources, especially for user inputs to prevent security issues.
117119	if it is untrusted html then you need to sanitise it to make it safe. that generally means parsing it with a dom parser, and then removing all elements and attributes that do not appear on a whitelist as safe (some attributes may be special cased to be filtered rather than stripped), and then converting the dom back to html. tools like html purifier exist to do this.
117565	you may need to add session_start() to the top of the file.
117824	for your project you'll want to get the url from the header then tart a database connection.insert the url into the database. close the connection. no sanitation is necessary for pdo because it uses prepared statements.
118084	you would have ensured that ?problem_id= is numeric. all of your other fields may still be at risk though, so this isn't the proper way of securing against sql injection. you should look into pdo and mysqli, and their bindparam/bind_params functions.
118698	the sql stuff is fine, parameterised queries are the best-practice approach to prevent sql injection.
119064	you need to ensure that array member is set first. try using the result of isset($_post['s']) to ensure it is set before trying to access it.
119120	to check the encoding, you can use the file command in a shell. its output should be something like
119180	you are looking for array_search which will return the key associated with a given value, if it exists.
119418	you don't have a session_start() call in that code block. unless you start the session, any data you write to the $_session superglobal will not be preserved for you when the script exits.
119434	try using mysqli::multi_query() instead of mysqli::query(). it allows the execution of multiple queries at once.
119455	also, you should be passing the login name using a paramaterized statement to avoid an obvious security hole.
119546	you need to call session_start() at the top of each of your scripts
119605	array_diff returns elements in the first array that are not in the second so have $b before $a the arrays contain other arrays so you probably want to use array_column to get specifically the teacher_name column
119610	you have to have session_start(); on the very top of your code, after &lt;?php. since you are checking if the session is set without starting the sessions, your code will fail.
120009	add error reporting to the top of your file(s) which will help find errors.
120011	if you get a notice about a deprecated mysql library, then you may be forced to switching over to either the mysqli_ api or pdo, something you should be using nowadays, as it's deprecated as of php 5.5 and deleted as of php 7.0
120086	session variables are stored on your server, not on the users computer like a cookie. so the user can't ever modify $_session['username']. the only thing you have to really be wary of with sessions is session hijacking (where a user gets the session id of another logged in user, and uses it to pose as that user)
120189	you can do this with pdo or mysqli , your current version of mysql is deprecated and strongly advised not to use it, instead look into mysqli and pdo which have methods in place for exactly what you want to do,
120210	isset will return a boolen, not a string that you are expecting.
120215	you have to call session_start() each time working with a session (not only when creating it)
120411	in order to make dealing with the session possible add session_start(); to the top of your script.
120412	the simple answer is that you need to put session_start() at the top of the script (and the top of any script that uses the session variables).
120416	you should also look into binding parameters in queries, which would allow you to avoid having to think about escaping values before running queries.
120537	i'm sticking within the scope of your question here, but something to note is that you best sanitize that information. especially if you're going to use it in a database query!
120775	yes but htmlentities() is good for sending data as output to the browser, not for storing it into the database (as the data from the db might be used for something other than a web page).
121137	for security reasons i also suggest you use pdo instead of mysql functions and $_post instead of $_request (in case you are not already sending your form per post).
121172	there's nothing special whatsoever about post requests and sessions.you just need to call session_start at the top of every file request you want to use sessions in, that's it.
121345	you really should be using something like filter_var() or parse_url() instead of regexes for url validation.
121561	the leading concept in programming is "don't trust user input". so the main problem in your case is not a special character its how you work with your data. so you shouldn't use a path given by a user because the user can manipulate the path or other variables.
121562	to escape a user input to prevent bad characters you can use htmlspecialchars or you can filter your get input with filter_input something like that:
121609	yes. always. or, better yet use placeholders (which are available in both pdo and mysqli) see best way to stop sql injection in php.
121612	the user enters data. the database stores the data. the point of "escaping" the data (or, better yet, use placeholders/parameterized queries) is making sure the data makes it into the database correctly and safely. if the data needs to be treated specially, then handle this at the data level -- the actual operation of dealing with the sql should be simple, consistent, and reliable. (note that mysql_real_escape_string doesn't change the data seen by the database, rather it ensures that the data is the real data -- that which was passed to the mysql_real_escape_string function -- after the database parses the sql command.)
121822	however, you probably want to use empty() instead of isset(). if a variable exists and contains an empty string, isset() will still return true, which probably isn't what you want. you probably want this:
122226	array_filter is used for filtering out elements of an array based on whether they satisfy a certain criterion. so you create a function that returns true or false, and test each element of the array against it. your function will always return true, since every array has a first element in it, so the array is unchanged.
122227	what you're looking for is array_map, which modifies each element in an array by running the callback over it.
122256	bound parameters are still safer though.  even though mysql_real_escape_string knows a lot about the connection and so on, a lot of factors can contribute to the security of it.  for example, character sets and encodings can be difficult to handle.  bound parameters have a different method of operation, and they do not do escaping like normal queries.  as such, they are safer as there is less room for error on things like character encoding and what not.
122444	you have to pay attention to the comparison operator: using $pos != false is not enough because 0 == false. you have to compare using === or !== to avoid this.
122787	this uses mysqli and prepared statements (for security), instead of the depracated mysql extension (in php 5.5)
123283	so, if there are really no dynamically changed parameters, there is no use in preparing and executing. just use pdo query method.
123435	the second method there, will throw a notice error if the variable is not set. you should use isset to check if a variable is set, that's what it is for.
123846	new way: all you gotta do is create a new pdo object. pdo's constructor takes at most 4 parameters, dsn, username, password, and an array of driver options.
123847	a dsn is basically a string of options that tell pdo which driver to use, and the connection details... you can look up all the options here pdo mysql dsn
124370	single quotes (') are not interpolated. double quotes (') are. also, you should not be using $_post["email"] directly in your query - it's a security hole and open to abuse. i assume you know this, as you're already using $newemail to hold an escaped version. try this:
124981	$_post is an array, you access arrays with [], so:
125002	i think the value for the $_post['color'] should be read only after checking if its set.
125129	if the query contains parameters, then prefer using pdo::prepare() and pdostatement::execute() instead of pdo::query(). you can find an example in the documentation for pdo::prepare().
125309	isset() just checks whether the variable is null or not and won't throw an e_notice error if you accessed an undefined index in an array (unlike is_null()).
125312	empty() will return false if there is no assignment to that variable.
125418	you are misunderstanding how in_array works. in_array checks the values. you want to check the keys.
125734	to remove duplicate values then we can use array_unique() function. the functionality of it is to accept an array and returns another array without duplicate values.
126189	persistent connections are a good idea only when it takes a (relatively) long time to connect to your database. nowadays that's almost never the case. the biggest drawback to persistent connections is that it limits the number of users you can have browsing your site: if mysql is configured to only allow 10 concurrent connections at once then when an 11th person tries to browse your site it won't work for them.
126208	array_intersect_key() is a suitable call to filter an array using another array's keys.
126778	pdo supports more than one database backend. this helps should one of your clients request a port of your application to a different database.prepared statements in pdo support named placeholders in addition to the positional (?) placeholders that mysqli supports.pdo supports binding a single parameter at a time instead of all parameters at once. this allows stepping through an array of arguments and binding each, instead of having to construct a type string and then use call_user_func_array() black magic.pdo supports a convenient shortcut by passing an array to $stmt-&gt;execute(), where each key's value is bound to the placeholder as the key. (caveat: it casts each value to a string, so you have to bind one at a time if your statement has a variable limit. this is documented, and there's a feature request to change this casting to string.)